<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
    <script>
        let tokenData = {
            "tokenId": "250",
            "hash": "0x1b47570d7fca8268eae2bbbecb452da392f909366abfe3885ed854b2273a9a78"
        }
    </script>
    <style type="text/css">
        html {
            height: 100%;
        }

        body {
            min-height: 100%;
            margin: 0;
            padding: 0;
        }

        canvas {
            padding: 0;
            margin: auto;
            display: block;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
        }
    </style>
</head>

<body>
    <canvas id="babylon-canvas"></canvas>

    <script>
        const t3 = THREE; class e { constructor() { this.useA = !1; let e = function (e) { let t = parseInt(e.substr(0, 8), 16), r = parseInt(e.substr(8, 8), 16), n = parseInt(e.substr(16, 8), 16), o = parseInt(e.substr(24, 8), 16); return function () { t |= 0, r |= 0, n |= 0, o |= 0; let e = (t + r | 0) + o | 0; return o = o + 1 | 0, t = r ^ r >>> 9, r = n + (n << 3) | 0, n = n << 21 | n >>> 11, n = n + e | 0, (e >>> 0) / 4294967296 } }; this.prngA = new e(tokenData.hash.substr(2, 32)), this.prngB = new e(tokenData.hash.substr(34, 32)); for (let e = 0; e < 1e6; e += 2)this.prngA(), this.prngB() } random_dec() { return this.useA = !this.useA, this.useA ? this.prngA() : this.prngB() } } class t { constructor(e, t = {}) { this.uniforms = t, this.material = new t3.ShaderMaterial({ fragmentShader: e, vertexShader: ge, uniforms: t }), this.scene = new t3.Scene, this.scene.add(new t3.Mesh(new t3.PlaneBufferGeometry(2 * G, 2 * b), this.material)) } } class r { constructor(e, t) { this.renderer = e, this.readBuffer = new t3.WebGLRenderTarget(t.width, t.height, { minFilter: t3.LinearFilter, magFilter: t3.LinearFilter, format: t3.RGBAFormat, type: t3.HalfFloatType, encoding: t3.sRGBEncoding, samples: 0, anisotropy: 0, stencilBuffer: !1 }), this.writeBuffer = this.readBuffer.clone() } swap() { const e = this.readBuffer; this.readBuffer = this.writeBuffer, this.writeBuffer = e } render(e, t, r = !1) { r ? this.renderer.render(e, t) : (this.renderer.setRenderTarget(this.writeBuffer), this.renderer.clear(), this.renderer.render(e, t), this.renderer.setRenderTarget(null)), this.swap() } dispose() { this.readBuffer.dispose(), this.writeBuffer.dispose() } } class n { constructor(e, t, r) { this.cPos = fr(-100, -100), this.pPos = fr(-101, -101), this.cVel = fr(), this.cType = t, this.segQueue = new Yr, this.pQueue = new Yr, this.color1 = r[0], this.color2 = r[1], this.poly = e, this.bufferObjects = null, this.bufferManager = null, this.polyDataTex = T, this.bL = D, this.tR = _, this.rV = fr(ar(), ar()), this.recalculateOptions(this.cType), this.finished = !1 } update() { let e = q; if (this.pQueue.getCount() > 0) e = this.pQueue.dequeue(); else { this.getNewSegment() ? this.pQueue.getCount() > 0 && (e = this.pQueue.dequeue()) : this.finished = !0 } this.pPos.set(this.cPos.x, this.cPos.y), this.cPos.set(e.x, e.y), this.cVel.set(this.cPos.x - this.pPos.x, this.cPos.y - this.pPos.y), this.cVel.normalize() } getNewSegment() { if (this.segQueue.getCount() > 0) { let e = this.segQueue.dequeue(); return this.processSegment(e.a, e.b, e.d, e.end), !0 } return !1 } processSegment(e, t, r, n) { let o = r / K; for (let r = 0; r < o; r++) { let n = e.clone().lerp(t, r / o); n = mt(n), isNaN(n.x) || isNaN(n.x) || vt(n) && this.pQueue.enqueue(n) } n && 0 != r && vt(t) && this.pQueue.enqueue(t.clone()) } recalculateOptions(e) { let t = j[e]; this.rA = t.randomAmount, this.width = t.brushWidth, this.frequency = t.brushFrequency, this.offsetSpeed = t.offsetSpeed } dispose() { null != this.bufferManager && (this.bufferManager.dispose(), this.bufferManager = null) } createBufferObjects() { let e = 0, n = 2, o = 0, l = !0, a = this.poly.brushVars; null != a && (e = a.borderPosition, o = a.borderThickness, n = a.fillPosition, l = null == a.enableShading || a.enableShading), this.bufferObjects = function (e, n, o, l, a, h) { let u = e.tR.x - e.bL.x, c = e.tR.y - e.bL.y, f = .75 * u, d = .75 * c, p = dr().clamp(Math.ceil(f * y), 0, 1800), g = dr().clamp(Math.ceil(d * v), 0, 2700); if (p < 2 || g < 2) return { bufferManager: null, dataTex: k, flagged: !0 }; const x = 0; let b = p, m = g, w = new r(s, { width: b, height: m }), P = e.verts[0][0] == e.verts[e.verts.length - 1][0] && e.verts[0][1] == e.verts[e.verts.length - 1][1], R = 0; P && (R = -1); let C = e.verts, B = C.length + R; const L = new Float32Array(1 * B * 4); let S = 0; for (let e = 0; e < B; e++)L[S++] = C[e][0], L[S++] = C[e][1], L[S++] = 0, L[S++] = 0; let M = e.bL.clone().sub(fr(.25 * u, .25 * c)); if (n) { const e = new t3.DataTexture(L, B, 1); e.type = t3.FloatType, e.format = t3.RGBAFormat, e.wrapS = t3.ClampToEdgeWrapping, e.wrapT = t3.ClampToEdgeWrapping, e.minFilter = t3.NearestFilter, e.magFilter = t3.NearestFilter, e.needsUpdate = !0; let r = new t(xe, { iResolution: { value: fr(b, m) }, polygon: { value: e }, dataMax: { value: B }, numVerts: { value: C.length }, polyWidth: { value: u }, polyHeight: { value: c }, padding: { value: x }, polyBL: { value: M }, randomOffset: { value: fr(ar(0, 1), ar(0, 1)) }, resFactor: { value: Y }, outlinePosition: { value: l }, outlineThickness: { value: a }, fillPosition: { value: o }, enableShading: { value: h }, softenEdges: { value: E.uniforms.softenEdges.value } }); w.render(r.scene, i), e.dispose() } let A = new t(be, { iResolution: { value: fr(b, m) }, iChannel0: { value: n ? w.readBuffer.texture : T }, randomOffset: { value: fr(ar(0, 1), ar(0, 1)) }, polyWidth: { value: u }, polyHeight: { value: c }, polyBL: { value: M }, resFactor: { value: Y } }); return w.render(A.scene, i), { bufferManager: w, dataTex: w.readBuffer.texture, flagged: !1 } }(this.poly, a.shapeMask, n, e, o, l), this.bufferManager = this.bufferObjects.bufferManager, this.polyDataTex = this.bufferObjects.dataTex, this.skipRendering = this.bufferObjects.flagged, this.bL = fr(this.poly.bL.x, this.poly.bL.y), this.tR = fr(this.poly.tR.x, this.poly.tR.y) } } class o { constructor(e, t, r, n) { this.verts = e, this.dataTex = null, this.shapeMask = n, this.eraseMaskTex = null, this.tL, this.tR, this.bR, this.bL, this.circle = [], this.center, this.bbCenter, this.height, this.width, this.colors = null == t ? [x.getRandomColor(), x.getRandomColor()] : t, this.localIncrement = K, this.randomAngle = sr(0, 8) * (F / 4), this.brushVars = r, this.area < P || (this.recomputeBoundsReal(), X < H && X++, this.draw(r, this.colors)) } draw(e, t) { let r, o; switch (r = new n(this, e.brushType, t), p.enqueue(r), e.fillMode) { case "trisFull": o = this.computeTris(this.verts); for (let t = 0; t < o.length; t++)this.queueOffset(o[t], r, e.offset, e.initOffset, e.max); break; case "lines": let t = 0; t = "noise" == e.angle ? yr(this.center, .1, 1, O) * F : e.angle, this.lineFill(r, e.offset, t), this.computePointsOnPoly(this.verts, r); break; case "offset": this.queueOffset(this.verts, r, e.offset, e.initOffset, e.max), "thin" == e.brushType && this.computePointsOnPoly(this.verts, r); break; case "path": this.computePointsOnPoly(this.verts, r) } } drawPath(e, t, r) { let o; switch ("false" != e && (o = new n(this, t, r), p.enqueue(o)), e) { case "false": break; case "true": this.computePointsOnPoly(this.verts, o) } } drawOL(e, t, r, o, i) { let l = parseInt(e); if (l > 0) { let s; "none" != e && (s = new n(this, t, r), p.enqueue(s)), this.queueOffset(this.verts, s, o, i, l) } } queueOffset(e, t, r, n, o) { let i = e; this.recursiveOffset(i, t, r, n, 0, o) } recursiveOffset(e, t, r, n, o, i) { if (o >= i) return; let l = r, s = !1; 0 == o && (0 == n && (s = !0), l = n); let a = s ? [e] : this.offsetPoly(e, l); if (o++, null != a) for (let e = 0; e < a.length; e++)if (a[e].length > 2) if (a[e].length > 10) { let l = Mr(a[e], .002); this.computePointsOnPoly(l, t), this.recursiveOffset(l, t, r, n, o, i) } else this.computePointsOnPoly(a[e], t), this.recursiveOffset(a[e], t, r, n, o, i) } offsetPoly(e, t) { let r = null; if (or(e), t < 0) try { r = u.data(e).arcSegments(3).padding(Math.abs(t)) } catch (e) { } else try { r = u.data(e).arcSegments(3).margin(t) } catch (e) { } return r } computeLineSegments() { let e = this.verts, t = []; for (let r = 0; r < e.length - 1; r++) { let n = r + 1, o = [e[r][0], e[r][1]], i = [e[n][0], e[n][1]]; t.push([o, i]) } return t } recomputeBoundsReal() { let e = Mt(this.verts); this.tL = e[0], this.tR = e[1], this.bR = e[2], this.bL = e[3]; let t = this.bL.x, r = this.tR.x, n = this.bL.y, o = this.tR.y; this.width = r - t, this.height = o - n, this.bbCenter = fr(.5 * (r - t) + t, .5 * (o - n) + n), this.center = this.bbCenter } computeTris(e, t) { } lineFill(e, t, r = 0, n = null) { this.lS = this.computeLineSegments(); let o = t, i = at(this.verts, r), l = (nt(i), fr(i[1][0], i[1][1])), s = fr(i[2][0], i[2][1]), a = fr(i[0][0] - i[1][0], i[0][1] - i[1][1]), h = gr(i[1][0], i[1][1], i[2][0], i[2][1]) / o, u = fr(), c = fr(), f = !1, d = []; for (let e = 0; e <= h; e++) { u.set(s.x, s.y).lerp(l, e / h), c.set(u.x, u.y).add(a); let t = [], r = [rr(u), rr(c)]; for (let e = 0; e < this.lS.length; e++) { let n = Kt(r[0], r[1], this.lS[e][0], this.lS[e][1]); n && t.push(n) } if (t.length > 0 && t.length % 2 == 0) { f = !0; for (let e = 0; e < t.length; e += 2) { let r = [t[e], t[e + 1]]; d.push(r) } } else if (0 == t.length && f) break; 0 } ir(d); for (let t = 0; t < d.length; t++)this.computePointsOnPoly(d[t], e) } computePointsOnPoly(e, t) { let r = fr(), n = fr(), o = (e[0][0] == e[e.length - 1][0] && (e[0][1], e[e.length - 1][1]), null), i = 0; for (; i < e.length - 1;) { let l = i + 1; if (r.set(e[i][0], e[i][1]), n.set(e[l][0], e[l][1]), o = n.clone().sub(r).length(), 0 == o) { i++; continue } i++; let s = i >= e.length - 1; t.segQueue.enqueue({ a: r.clone(), b: n.clone(), d: o, end: s }) } } } let i, l, s, a, h, u, c = !1, f = !1, d = !1; t3.Cache.enabled = !0; let p, g, y, v, x, b, m, w, P, R, C, E, B, L, S, T, k, M, A, I, W, N, F = Math.PI, O = fr(), _ = fr(1, 1), D = fr(-1, -1), q = fr(100, 100), V = fr(), z = cr(), j = (fr(), []), U = [], H = 3, X = 0, Y = 1, J = 0, G = 1, subIdInt = 0, Q = [], $ = 3, K = .02, Z = .0025, ee = 4e-5, te = [], re = !1, ne = 9999, oe = 1, ie = 45, le = 30, se = 0, ae = .016667, he = 30, ue = !1, ce = "", fe = "", de = 0, pe = "Low"; const ge = "\n    precision highp float;      \n    varying vec2 vUv;\n    \n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n    }\n", ye = "\nprecision highp sampler2D;precision highp float;\n#define NUM_OCTAVES 3\n#define H(p)fract(sin(mod(dot(p,vec2(12.9898,78.233)),6.283))*43758.5453)\n#define NUM_BRUSHES 3\n#define PI 3.14159265359\nuniform float resFactor;uniform sampler2D iChannel0;uniform vec2 iResolution;uniform float iFrame;varying vec2 vUv;uniform sampler2D iChannel2,posNoiseTexture;uniform float isWaterColor,isSig,uvFlip,softenEdges;struct Brush{vec2 sCurrent;vec2 sPrevious;vec2 sVel;vec3 sColor1;vec3 sColor2;int dataTexIndex;float randomAmount;float brushWidth;float brushFrequency;float offsetSpeed;vec2 bL;vec2 tR;vec2 rV;};uniform Brush brushes[3];uniform sampler2D dataTex0,dataTex1,dataTex2;float hd(vec2 from,vec2 to){float dx=abs(to.x-from.x),dy=abs(to.y-from.y),md=max(dy,dx);return.394*(dx+dy)+.554*md;}float hd(vec3 from,vec3 to){float dx=abs(to.x-from.x),dy=abs(to.y-from.y),dz=abs(to.z-from.z),md=max(dz,max(dy,dx));return.394*(dx+dy+dz)+.554*md;}float gt(float x,float y){return max(sign(x-y),0.);}float pN(vec2 p,float t){float result=0.,amplitude=.5,falloff=.5,lucunarity=.5;p=p+.5+vec2(t);for(float index=0.;index<3.;++index)result+=texture(iChannel2,p).x*amplitude,p*=lucunarity,amplitude*=falloff;return result;}float random(vec2 st){return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);}float distSquare(vec2 A,vec2 B){vec2 C=A-B;return dot(C,C);}float nDLS(vec2 v,vec2 w,vec2 p){float l2=distSquare(v,w),t;if(l2==0.)return hd(p,v);t=max(0.,min(1.,dot(p-v,w-v)/l2));vec2 projection=v+t*(w-v);return hd(p,projection);}float eq(float xx,float yy){return 1.-abs(sign(xx-yy));}void main(){float tt=floor(iFrame/15.)*12.69,totalPaint,colorCount,mixed,blendInclude,blendMax,blendFactor,threshold;vec2 uv=(gl_FragCoord.xy-iResolution.xy/2.)/iResolution.x*2.,uv2,totalOffset;uv.x*=uvFlip;uv2=gl_FragCoord.xy/iResolution.xy;vec3 totalColor=vec3(0);totalPaint=0.;totalOffset=vec2(0);colorCount=0.;for(int i=0;i<NUM_BRUSHES;i++){Brush cBrush=brushes[i];vec2 bLo=cBrush.bL,tRo=cBrush.tR;float pWidth=tRo.x-bLo.x,pHeight=tRo.y-bLo.y,nX,nY,xR,yR,maskThreshold,picker;bLo-=vec2(pWidth*.25,pHeight*.25);tRo+=vec2(pWidth*.25,pHeight*.25);nX=(uv.x-bLo.x)/(tRo.x-bLo.x);nY=(uv.y-bLo.y)/(tRo.y-bLo.y);xR=random(vec2(nX,nY))*6e-4*softenEdges;yR=random(vec2(nY,nX))*6e-4*softenEdges;nX=nX+(xR,yR);nY=nY+(yR,xR);vec4 dataT0=texture(dataTex0,vec2(nX,nY)),dataT1=texture(dataTex1,vec2(nX,nY)),dataT2=texture(dataTex2,vec2(nX,nY)),dataT=dataT0*eq(float(cBrush.dataTexIndex),0.)+dataT1*eq(float(cBrush.dataTexIndex),1.)+dataT2*eq(float(cBrush.dataTexIndex),2.);maskThreshold=mix(gt(cBrush.rV.x,.666),0.,isWaterColor);picker=mix(dataT.w,dataT0.w+dataT1.w+dataT2.w,maskThreshold);if(picker>0.){float masked=gt(dataT.w,0.),dd,lP,mL,brightnessNoise,isBorder,paint,paintFactor,brushWidthFactor,intensifyInside,featherOutside,brush,factor,push,potentialColorCount;vec2 current=cBrush.sCurrent,prev=cBrush.sPrevious,velocity=cBrush.sVel,pos,offset;velocity.x*=uvFlip;pos=uv-current;dd=nDLS(prev,current,uv);lP=hd(pos,vec2(0));mL=mix(dd,lP,gt(hd(current,prev),.1));brightnessNoise=round(dataT.x)-.5;vec3 currentColor=mix(cBrush.sColor2,cBrush.sColor1,pow(dataT.y,1.)),outlineColor;currentColor+=vec3(brightnessNoise*.015);currentColor+=.05*pow(dataT.z,1.)-.025;isBorder=gt(dataT.w,.5)*(1.-eq(dataT.w,.5));outlineColor=mix(clamp(currentColor-.2,0.,1.),clamp(currentColor-.5,0.,1.),isWaterColor);outlineColor*=1.2;currentColor=mix(currentColor,outlineColor,isBorder);paint=pN(vec2(pos.xy*cBrush.brushFrequency),tt);paintFactor=1.-clamp(mL*.75,0.,cBrush.brushWidth)/cBrush.brushWidth;brushWidthFactor=1.-gt(cBrush.brushWidth,.04);intensifyInside=pow(paintFactor,2.)*brushWidthFactor*.2;featherOutside=pow(paintFactor,.2);paint+=mix(intensifyInside,0.,isWaterColor);paint*=mix(featherOutside,.98,isWaterColor);paint+=mix(0.,1.,isSig);paint*=mix(1.,pow(paintFactor,.5),isSig);brush=1.-gt(mL,cBrush.brushWidth)+mix(0.,random(uv)*.01,isSig);factor=pow(clamp(mL*.5,0.,cBrush.brushWidth)/cBrush.brushWidth,3.);brush*=1.-factor;paint*=brush;paint*=masked;push=smoothstep(.35,.5,paint);push*=smoothstep(.4,1.,brush)*(1.-isBorder*.75);offset=cBrush.offsetSpeed*push*-velocity/(iResolution.xy/resFactor);totalOffset+=offset*brush;totalPaint=max(totalPaint,paint);totalColor+=currentColor*ceil(brush);potentialColorCount=colorCount+1.;colorCount=mix(colorCount,potentialColorCount,ceil(brush));}}colorCount=clamp(colorCount,1.,100.);totalColor/=colorCount;vec4 frame=texture(iChannel0,uv2+totalOffset);mixed=max(totalPaint,frame.w);mixed=clamp(mixed,0.,1.);blendInclude=mix(gt(brushes[0].rV.y,.25),1.,isWaterColor);blendMax=mix(.08,.25,isWaterColor);blendFactor=mix(.04,blendMax,blendInclude);threshold=max(frame.w-blendFactor,0.);if(totalPaint>threshold)totalColor*=1.;else totalColor=frame.xyz;gl_FragColor=vec4(clamp(totalColor.x,0.,1.),clamp(totalColor.y,0.,1.),clamp(totalColor.z,0.,1.),mixed);}\n", ve = "\nprecision highp sampler2D;precision highp float;uniform sampler2D iChannel0,posNoiseTexture;uniform vec3 iResolution;varying vec2 vUv;uniform vec3 bgCol;uniform float blackAndWhite,blackPaper,randomTime,randomRot,isWaterColor,resFactor,isDone;\n#define TEX0(uv)texture(iChannel0,uv).w\n#define TEX1(uv)texture(iChannel1,uv).r\n#define PI 3.1415926538\nfloat hash(vec2 p){vec3 p3=fract(p.xyx*.1031);p3+=dot(p3,p3.yzx+33.33);return fract((p3.x+p3.y)*p3.z);}float noise(vec2 p){vec4 w=vec4(floor(p),ceil(p));float _00=hash(w.xy),_01=hash(w.xw),_10=hash(w.zy),_11=hash(w.zw),_0=mix(_00,_01,fract(p.y)),_1=mix(_10,_11,fract(p.y));return mix(_0,_1,fract(p.x));}float fbm(vec2 p){float o=0.;for(float i=0.;i<3.;i++)o+=noise(.1*p)/3.,o+=.2*exp(-2.*abs(sin(.02*p.x+.01*p.y)))/3.,p*=2.;return o;}vec2 grad(vec2 p){float n=fbm(p+vec2(0,1)),e=fbm(p+vec2(1,0)),s=fbm(p-vec2(0,1)),w=fbm(p-vec2(1,0));return vec2(e-w,n-s);}float hd(vec2 from,vec2 to){float dx=abs(to.x-from.x),dy=abs(to.y-from.y),md=max(dy,dx);return.394*(dx+dy)+.554*md;}float hd(vec3 from,vec3 to){float dx=abs(to.x-from.x),dy=abs(to.y-from.y),dz=abs(to.z-from.z),md=max(dz,max(dy,dx));return.394*(dx+dy+dz)+.554*md;}vec2 hn(vec2 o){float m=hd(o,vec2(0));return o/m;}vec3 hn(vec3 o){float m=hd(o,vec3(0));return o/m;}vec2 rotate(vec2 v,float a){float s=sin(a),c=cos(a);mat2 m=mat2(c,-s,s,c);return m*v;}float gt(float x,float y){return max(sign(x-y),0.);}float lt(float x,float y){return max(sign(y-x),0.);}mat4 brightnessMatrix(float brightness){return mat4(1,0,0,0,0,1,0,0,0,0,1,0,brightness,brightness,brightness,1);}mat4 contrastMatrix(float contrast){float t=(1.-contrast)/2.;return mat4(contrast,0,0,0,0,contrast,0,0,0,0,contrast,0,t,t,t,1);}mat4 saturationMatrix(float saturation){vec3 luminance=vec3(.3086,.6094,.082),red,green,blue;float oneMinusSat=1.-saturation;red=vec3(luminance.x*oneMinusSat);red+=vec3(saturation,0,0);green=vec3(luminance.y*oneMinusSat);green+=vec3(0,saturation,0);blue=vec3(luminance.z*oneMinusSat);blue+=vec3(0,0,saturation);return mat4(red,0,green,0,blue,0,0,0,0,1);}float rand(float x){return fract(sin(x)*43758.5453);}float triangle(float x){return abs(1.-mod(abs(x),2.))*2.-1.;}float getHatch(vec2 p){float diffuse=1.,xs=rand(randomTime*6.6)*.1+.9,ys=rand(randomTime*6.6)*.1+.9,hatching=max(clamp(sin(p.x*xs*(170.+rand(randomTime)*30.1)+p.y*ys*(110.1+rand(randomTime*1.92)*30.1))*.5+.5-1.+diffuse,0.,1.),clamp(sin(p.x*xs*(-110.1+rand(randomTime*4.75)*30.)+p.y*ys*(170.1+rand(randomTime*3.91)*30.1))*.5+.5-1.+diffuse-.4,0.,1.));return hatching;}void main(){vec3 color=vec3(0),preColor,unit,normal,dir,tint,paperColor,bumpedColor;vec2 uv=gl_FragCoord.xy/iResolution.xy,q=gl_FragCoord.xy/iResolution.xy,p,fadeUV,paintSwitch;q=rotate(q,randomRot*2.*PI);p=-1.+10.*q;p.x*=-iResolution.x/iResolution.y;p+=vec2(triangle(p.y*rand(randomTime)*4.)*rand(randomTime*1.9)*.15,triangle(p.x*rand(randomTime*3.4)*4.)*rand(randomTime*2.1)*.15);p+=vec2(rand(p.x*3.1+p.y*8.7)*.01,rand(p.x*1.1+p.y*6.7)*.01);float hatch=mix(round(getHatch(p)),0.,isWaterColor),bump,gray,edgeX,edgeY,edges,specular,average,mx,saturationFactor;vec4 baseTex=texture(iChannel0,uv).xyzw,finalColor;preColor=baseTex.xyz;bump=grad(gl_FragCoord.xy).x;gray=baseTex.w;if(isDone>0.&&gray<=0.){float inside=gt(uv.x,.02)*gt(uv.y,.015)*lt(uv.x,.98)*lt(uv.y,.985);inside=1.-inside;vec2 newUV=vec2(mod(uv.x+.5,1.),mod(uv.y+.5,1.));newUV=vec2(clamp(newUV.x,.02,.98),clamp(newUV.y,.015,.985));vec4 newColor=texture(iChannel0,newUV).xyzw;gray=mix(newColor.w,gray,inside);preColor=mix(newColor.xyz,preColor,inside);}gray=mix(clamp(gray-.03,0.,1.)+hatch*.06,gray,isWaterColor);fadeUV=(uv-.5)*2.;edgeX=pow(abs(fadeUV.x),8.);edgeY=pow(abs(fadeUV.y),9.);edges=clamp(edgeX+edgeY,0.,1.);unit=mix(mix(vec3(clamp(resFactor,0.,1.5)/iResolution.xy,0),vec3(0),edges),vec3(clamp(.5*resFactor,0.,1.5)/iResolution.xy,0),isWaterColor);normal=normalize(vec3(TEX0(uv+unit.xz)-TEX0(uv-unit.xz),TEX0(uv-unit.zy)-TEX0(uv+unit.zy),pow(gray,3.)));dir=hn(vec3(0,1,2));specular=pow(dot(normal,dir)*.5+.5,16.);tint=vec3(1);dir=normalize(vec3(uv-.5,0));color+=tint*pow(dot(normal,-dir)*.5+.5,.5)*.5+.5;color*=preColor;color+=vec3(.3)*specular;color*=1.-pow(edges,1.35)*.065;paperColor=bgCol;bumpedColor=(vec3(.98)+hatch*.02)*.925+bump*.075;paintSwitch=mix(vec2(.3,.5),vec2(.35,.7),isWaterColor);color=mix((paperColor+hatch*.03)*.925+bump*.075,clamp(color,0.,1.5)*bumpedColor,smoothstep(paintSwitch.x,paintSwitch.y,gray));color*=mix(1.01,.85,pow(hd(uv-.666,vec2(0)),1.2));color=clamp(color,0.,1.);finalColor=vec4(color,1);finalColor=mix(finalColor,color.yyyy,blackAndWhite);average=(finalColor.x+finalColor.y+finalColor.z)/3.;mx=max(finalColor.x,max(finalColor.y,finalColor.z));finalColor=finalColor-(mx-finalColor)*((mx-average)*.01*3.*5.);saturationFactor=mix(1.,1.35,pow(edges,1.35));gl_FragColor=brightnessMatrix(.01)*contrastMatrix(1.05)*saturationMatrix(1.01*saturationFactor)*finalColor;}\n", xe = "\nprecision highp sampler2D;precision highp float;varying vec2 vUv;uniform int numVerts;uniform sampler2D polygon,posNoiseTexture;uniform vec2 iResolution;uniform float polyWidth,polyHeight;uniform vec2 polyBL;uniform float dataMax;uniform vec2 randomOffset;uniform float padding,resFactor;uniform bool enableShading;uniform float softenEdges,fillPosition,outlinePosition,outlineThickness;float random(vec2 _st){return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);}\n#define NUM_OCTAVES 3\n#define PI 3.1415926538\nfloat distSquare(vec2 A,vec2 B){vec2 C=A-B;return dot(C,C);}float nDLS(vec2 v,vec2 w,vec2 p){float l2=distSquare(v,w),t;if(l2==0.)return distance(p,v);t=max(0.,min(1.,dot(p-v,w-v)/l2));vec2 projection=v+t*(w-v);return distance(p,projection);}vec2 sdPolygon(vec2 p){vec2 iUV=vec2(0,.5);float pIX=texture2D(polygon,iUV).x,pIY=texture2D(polygon,iUV).y,d=dot(p-vec2(pIX,pIY),p-vec2(pIX,pIY)),s=1.,nearest=1e3;for(int i=0,j=numVerts-1;i<numVerts;j=i,i++){iUV=vec2(float(i)/(dataMax-1.),.5);vec2 jUV=vec2(float(j)/(dataMax-1.),.5),pJ,pI,e,w,b;pIX=texture2D(polygon,iUV).x;pIY=texture2D(polygon,iUV).y;float pJX=texture2D(polygon,jUV).x,pJY=texture2D(polygon,jUV).y,nd;pJ=vec2(pJX,pJY);pI=vec2(pIX,pIY);nd=nDLS(pI,pJ,p);nearest=min(nearest,nd);e=pJ-pI;w=p-pI;b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=pIY,p.y<pJY,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond)))s=-s;}return vec2(s*sqrt(d),nearest);}void main(){vec2 uv=gl_FragCoord.xy/iResolution.xy;float edgeLX=1./iResolution.x,edgeBY=1./iResolution.y,edgeRX=1.-edgeLX,edgeTY=1.-edgeBY;if(uv.x<edgeLX||uv.x>edgeRX||uv.y<edgeBY||uv.y>edgeTY)gl_FragColor=vec4(0);else{float pX=uv.x*1.5*polyWidth+polyBL.x,pY=uv.y*1.5*polyHeight+polyBL.y,xR=random(vec2(pX,pY))*6e-4*softenEdges,yR=random(vec2(pY,pX))*6e-4*softenEdges,relativeRes,edge,inside,d;vec2 offset=vec2(0),insideVars=sdPolygon(vec2(pX+offset.x+xR,pY+offset.y+yR));relativeRes=1./(iResolution.x/(1800.*resFactor));edge=insideVars.x*iResolution.x*relativeRes;inside=0.;if(edge<outlinePosition*resFactor+outlineThickness*resFactor*.5&&edge>outlinePosition*resFactor-outlineThickness*resFactor*.5)inside=1.;else if(edge>fillPosition*resFactor)inside=0.;else inside=.5;d=enableShading?insideVars.y:1e3;gl_FragColor=vec4(inside,d,0,0);}}\n", be = "\nprecision highp sampler2D;precision highp float;\n#define NUM_OCTAVES 2\n#define PI 3.1415926538\nvarying vec2 vUv;uniform sampler2D iChannel0;uniform vec2 iResolution;uniform float polyWidth,polyHeight;uniform vec2 polyBL,randomOffset;uniform float resFactor;float random(vec2 _st){return fract(sin(dot(_st.xy,vec2(12.9898,78.233)))*43758.5453123);}float noise(vec2 _st){vec2 i=floor(_st),f=fract(_st),u;float a=random(i),b=random(i+vec2(1,0)),c=random(i+vec2(0,1)),d=random(i+vec2(1));u=f*f*(3.-2.*f);return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}vec2 rotate(vec2 v,float a){float s=sin(a),c=cos(a);mat2 m=mat2(c,-s,s,c);return m*v;}void main(){vec2 uv=gl_FragCoord.xy/iResolution.xy,worldPos,strokeOffset,bNCoord;vec4 polygonTexture=texture2D(iChannel0,uv);worldPos=vec2(uv.x*polyWidth+polyBL.x,uv.y*polyHeight+polyBL.y);float strokeOffsetAmount=random(vec2(round(worldPos.y*200.),0)),bN,dToEdge,uvN;strokeOffset=vec2(strokeOffsetAmount,0);bNCoord=vec2(worldPos.x*4.,worldPos.y*2.)*4.-strokeOffset;bNCoord=rotate(bNCoord,randomOffset.y*2.*PI);bN=1.-noise(bNCoord-randomOffset.x*2334.21);dToEdge=clamp(polygonTexture.y*15.,0.,1.);uvN=clamp(pow(uv.y*2.-.5,2.),0.,1.);gl_FragColor=vec4(bN,uvN,dToEdge,polygonTexture.x);}\n", me = "\nprecision highp sampler2D;precision highp float;\n#define BLOOM_THRESHOLD 0.1\n#define BLOOM_INTENSITY 1.04\n#define BLUR_ITERATIONS 8\n#define BLUR_SIZE.045\n#define BLUR_SUBDIVISIONS 32\nvarying vec2 vUv;uniform sampler2D iChannel0;uniform vec2 iResolution,randomPos;uniform float blackAndWhite,intensityBoost,clampBloom;vec3 getHDR(vec3 tex){return max((tex-BLOOM_THRESHOLD)*(BLOOM_INTENSITY+intensityBoost),0.);}vec3 gaussian(sampler2D sampler,vec2 uv){vec3 sum=vec3(0);for(int i=1;i<=BLUR_ITERATIONS;i++){float angle=360./float(BLUR_SUBDIVISIONS);for(int j=0;j<BLUR_SUBDIVISIONS;j++){float dist=BLUR_SIZE*(float(i+1)/float(BLUR_ITERATIONS)),s=sin(angle*float(j)),c=cos(angle*float(j));sum+=getHDR(texture(sampler,uv+vec2(c,s)*dist).xyz);}}sum/=float(BLUR_ITERATIONS*BLUR_SUBDIVISIONS);return sum*(BLOOM_INTENSITY+intensityBoost);}void main(){vec2 uv=gl_FragCoord.xy/iResolution.xy;vec4 tx=texture(iChannel0,uv);vec3 color=gaussian(iChannel0,uv);float average=(color.x+color.y+color.z)/3.,mx=max(color.x,max(color.y,color.z)),vignette;color=color-(mx-color)*((mx-average)*.105*3.*5.);color=vec3(clamp(color.x,0.,clampBloom),clamp(color.y,0.,clampBloom),clamp(color.z,0.,clampBloom));vignette=clamp(pow(clamp(distance(vec2(uv.x+randomPos.x,uv.y+randomPos.y)*1.6,vec2(.5)),0.,1.),1.),0.,.925);color=mix(color*.35+tx.xyz,tx.xyz,vignette);gl_FragColor=vec4(color,1);}\n"; let we = [{ name: "Monotone", colors: [2236962, 4473924, 8947848, 13421772, 15658734] }, { name: "Ack", colors: [5675672, 3177090, 928091, 14279104, 13598336, 8443030, 4946087, 9135450, 3429742, 12375967, 4790554, 992057] }, { name: "Yun", colors: [15658725, 14339229, 8818016, 14060145, 9662823, 6972245, 10332020, 12498312, 11521493, 4144691] }, { name: "Kindergarten", colors: [16183272, 16305814, 15519056, 16348235, 12887162, 14734274, 7515757, 7840654, 3246250, 15322017] }, { name: "Burgundy", colors: [7279122, 5704716, 9240583, 10553617, 5112073] }, { name: "Picnic", colors: [15053076, 3887715, 12100731, 13184023, 12499112, 2454943, 7167538, 2829348, 15590597, 5915176] }, { name: "Serpent", colors: [1133407, 1741679, 8967320, 13032127, 15985106] }, { name: "Powder", colors: [12179186, 1256019, 218020, 28074, 13657] }, { name: "Karat", colors: [16768417, 16763730, 16559902, 16097312, 15371554] }, { name: "Animation", colors: [3158064, 6578775, 9540237, 14453136, 5151883, 15979386, 3438760, 12956833, 14472135, 15524565] }, { name: "Guernica", colors: [15395562, 11378848, 12300721, 12895949, 8159634, 13944002, 6844029, 10586499, 11249068, 6183005] }, { name: "Mariposa", colors: [1054513, 3558760, 16113858, 14103090, 15836789, 15841184, 13552584, 11844541, 8424590] }, { name: "Vermeer", colors: [143687, 862241, 4477527, 3089692, 1582637, 14402990, 12689789, 6180927, 8287077, 12554843] }, { name: "Spearmint", colors: [10386257, 5935017, 5584184, 14459553, 15195354, 1185853, 10664625, 15228993, 15716557, 16771287] }],
            Pe = [0, 775.903, 20.023, 724.176, 58.401, 637.409, 98.448, 565.658, 160.186, 473.885, 161.855, 487.234, 146.838, 525.612, 136.826, 570.664, 128.483, 627.397, 123.477, 679.124, 123.477, 720.839, 126.814, 754.211, 135.157, 755.88, 151.843, 740.862, 165.192, 714.165, 186.884, 659.1, 216.919, 594.025, 250.291, 533.955, 287.001, 475.553, 318.704, 427.164, 358.751, 367.094, 390.454, 318.704, 412.146, 292.007, 418.821, 302.018, 393.792, 350.408, 377.106, 402.135, 355.414, 470.548, 327.047, 568.996, 293.675, 695.81, 256.966, 829.299, 230.268, 952.776, 208.576, 1059.567, 193.559, 1161.352, 181.878, 1256.462, 190.221, 1328.213], Re = [589.019, 103.454, 590.687, 118.471, 580.676, 163.524, 552.309, 250.291, 527.28, 323.71, 498.914, 410.478, 477.222, 490.571, 450.524, 594.025, 430.501, 699.147, 418.821, 769.229, 412.146, 814.281, 415.484, 829.299, 427.164, 824.293, 445.519, 785.915, 478.891, 714.165, 510.594, 647.42, 545.635, 582.344, 585.682, 503.92, 635.74, 410.478, 687.467, 323.71, 730.851, 258.634, 742.531, 238.611, 752.543, 248.623, 712.496, 340.396, 645.752, 468.879, 604.036, 545.635, 574.001, 612.379, 550.641, 679.124, 537.292, 714.165, 532.286, 735.856, 553.978, 745.868, 575.67, 734.188, 610.711, 710.827, 640.746, 700.816, 667.443, 690.804, 677.455, 664.106, 694.141, 667.443, 697.478, 692.473, 694.141, 730.851, 704.153, 762.554, 734.188, 790.921, 750.874, 819.287, 769.229, 887.7, 779.24, 977.805, 782.577, 1057.898, 780.909, 1144.666, 769.229, 1243.113, 744.199, 1329.881, 712.496, 1396.625, 687.467, 1426.66, 667.443, 1436.672, 644.083, 1426.66, 629.065, 1396.625, 627.397, 1344.899, 632.403, 1261.468, 645.752, 1183.044, 662.438, 1097.945, 687.467, 1011.177, 715.833, 916.066, 740.862, 850.99, 780.909, 732.519, 817.618, 635.74, 862.671, 528.949, 907.723, 427.164, 946.101, 342.065, 986.148, 258.634, 1021.189, 196.896, 1052.892, 143.5, 1064.572, 126.814, 1072.915, 130.151, 1066.241, 145.169, 1017.851, 213.582, 971.13, 303.687, 934.421, 390.454, 902.717, 472.216, 881.025, 542.298, 862.671, 622.391, 859.333, 670.781, 861.002, 715.833, 872.682, 745.868, 886.031, 755.88, 902.717, 752.543, 924.409, 735.856, 951.107, 700.816, 979.473, 660.769, 994.491, 629.065, 1004.502, 612.379, 1016.183, 620.722, 1001.165, 657.432, 989.485, 700.816, 994.491, 727.513, 1021.189, 749.205, 1049.555, 734.188, 1062.904, 715.833, 1056.229, 694.141, 1036.206, 689.135, 1036.206, 675.787, 1069.578, 684.13, 1096.276, 680.792, 1121.305, 662.438, 1136.323, 644.083, 1148.003, 647.42, 1154.677, 659.1, 1151.34, 689.135, 1149.671, 719.17, 1159.683, 735.856, 1173.032, 737.525, 1188.049, 725.845, 1201.398, 665.775, 1226.427, 575.67, 1256.462, 478.891, 1291.503, 373.768, 1326.544, 278.658, 1356.579, 205.239, 1379.939, 140.163, 1409.974, 75.087, 1433.335, 25.029, 1448.352, 0, 1456.695, 3.337, 1451.69, 23.361, 1429.998, 65.076, 1386.614, 165.192, 1356.579, 251.96, 1331.55, 323.71, 1311.526, 382.111, 1294.84, 452.193, 1281.491, 532.286, 1276.486, 614.048, 1276.486, 665.775, 1278.154, 697.478, 1289.835, 725.845, 1303.183, 739.194, 1319.869, 739.194, 1333.218, 727.513, 1349.904, 697.478, 1371.596, 660.769, 1398.294, 625.728, 1424.992, 600.699, 1441.678, 589.019, 1448.352, 597.362, 1443.347, 615.717, 1436.672, 649.089, 1435.003, 674.118, 1441.678, 697.478, 1456.695, 709.159, 1478.387, 710.827, 1511.759, 702.484, 1538.457, 697.478, 1561.818, 704.153, 1576.835, 712.496, 1591.853, 719.17, 1605.202, 717.502, 1620.219, 712.496], Ce = [1563.486, 590.687, 1605.202, 580.676, 1653.591, 577.339, 1695.306, 580.676, 1742.027, 584.013, 1787.08, 587.35, 1838.807, 587.35, 1887.196, 582.344, 1923.906, 577.339, 1948.935, 570.664], Ee = "0xd41b2ae5027c6dfbf", Be = "922a90723773ff2d7da06c", Le = "9a37c3d6faea34c6579e360d3"; var Se, Te; function ke(e) { var t = e += 1831565813; return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296 } const Me = new Proxy(new URLSearchParams(window.location.search), { get: (e, t) => e.get(t) }); let Ae; function Ie() { if ("oilBorder" == Ae) for (let e = te.length - 1; e >= Math.max(0, te.length - 100); e--)if (te[e].length > 2 && te[e].length < 16) { let t = nt(te[e]); if (qe(t[0], -.95, .95) && qe(t[1], -1.4, 1.4)) { let e = Qt(4, .004, tr(t)); new o(e, I, Ot("tiny")) } } } let We = -1; function Ne(e, t, r, n = !0, o = 0, i = null) { null == i && (i = O); let l, s = We > 0 ? We : ar(.2, .6), a = "dome" == e ? .5 * s : "pillar" == e ? 0 : ar(.4, .8), h = n ? t.y - .5 * a - r[3][1] : ar(.5, .9); switch (e) { case "dome": l = function (e, t, r, n, o, i, l, s) { let a = [[.5 * -t + e.x, .5 * -t - n + e.y], [.5 * -t + e.x, -t + e.y]], h = fr(); for (let r = F - F / 12; r > 0; r -= F / 12)h.set(.5 * t, 0), h.rotateAround(O, r), h.x += e.x, h.y += e.y - .5 * t, a.push([h.x, h.y]); return a.push([.5 * t + e.x, -t + e.y], [.5 * t + e.x, .5 * -t - n + e.y]), Fe(a, o, i, l, s) }(t, s, 0, h, o, i, n, r); break; case "crown": l = function (e, t, r, n, o, i, l, s) { let a = [[.5 * -t + e.x, -r + e.y], [0 + e.x, 0 + e.y], [.5 * t + e.x, -r + e.y]]; return Fe(a, o, i, l, s) }(t, s, a, 0, o, i, n, r); break; case "trough": l = function (e, t, r, n, o, i, l, s) { let a = [[.5 * -t + e.x, e.y], [e.x, -r + e.y], [.5 * t + e.x, e.y]]; return Fe(a, o, i, l, s) }(t, s, a, 0, o, i, n, r); break; case "m": l = function (e, t, r, n, o, i, l, s) { let a = [[.5 * -t + e.x, -r + e.y], [.5 * -t + e.x, e.y], [e.x, .75 * (-r + e.y)], [.5 * t + e.x, e.y], [.5 * t + e.x, -r + e.y]]; ar() < .5 ? a.shift() : a.pop(); return Fe(a, o, i, l, s) }(t, s, a, 0, o, i, n, r); break; case "x": l = function (e, t, r, n, o, i, l, s) { let a = [[.5 * -t + e.x, -r + e.y], [0 + e.x, 0 + e.y], [.5 * t + e.x, -r + e.y]], h = Fe(a, o, i, l, s), u = [[.5 * -t + e.x, r + e.y], [0 + e.x, 0 + e.y], [.5 * t + e.x, r + e.y]], c = Fe(u, o, i, l, s), f = kt([h, c]); null != f && f.length > 0 && (h = f[0]); return h }(t, s, a, 0, o, i, n, r); break; case "obelisk": l = function (e, t, r, n, o, i, l, s) { let a = [[.5 * -t + e.x, -r - n + e.y], [.5 * -t + e.x, -r + e.y], [0 + e.x, 0 + e.y], [.5 * t + e.x, -r + e.y], [.5 * t + e.x, -r - n + e.y]]; return Fe(a, o, i, l, s) }(t, s, a, h, o, i, n, r); break; case "yArc": l = function (e, t, r, n, o, i, l, s) { let a = e.clone().add(fr(.5 * -t, 0)), h = e.clone().add(fr(.5 * t, 0)), u = e.clone(), c = e.clone().add(fr(0, -r)), f = c.clone().lerp(a, .5), d = c.clone().lerp(h, .5), p = u.clone().lerp(f, .5), g = u.clone().lerp(d, .5), y = gr(c.x, c.y, u.x, u.y), v = gr(u.x, u.y, a.x, a.y), x = (y + v) * ar(.25, .75), b = Je(c, p, a, x), m = Je(c, g, h, x), w = [b, m], P = null; if (n > 0) { let e = _e([[[c.x, c.y], [c.x, c.y - n]]], .012); null != e && e.length > 0 && (P = e[0]) } let R = _e(w, .012); R = kt(R); let C = [[100, 100], [101, 101]]; null != R && R.length > 0 && (C = R[0]); St(C, o, i, !1); let E = C; if (null != P) { St(P, o, i, !1); let e = kt([C, P]); null != e && e.length > 0 && (E = e[0]) } return E }(t, s, a, h, o, i); break; case "pillar": l = function (e, t, r, n, o, i, l, s) { let a = [[e.x, e.y], [e.x, .5 * -n + e.y], [e.x, -n + e.y]], h = Fe(a, o, i, l, s, 1); return h }(t, 0, 0, h, o, i, n, r) }return l } function Fe(e, t, r, n, o, i = 0) { let l = e; if (St(l, t, r, !1, !1), n) { let e = Oe(l[0], l[1], o), t = Oe(l[l.length - 1], l[l.length - 2], o); null == e || 0 != i && -1 != i || l.unshift(e), null == t || 0 != i && 1 != i || l.push(t) } let s = _e([l], .012), a = [[100, 100], [101, 101]]; return null != s && s.length > 0 && (a = s[0]), a } function Oe(e, t, r) { let n = tr(e), o = tr(t), i = n.clone().sub(o).normalize().multiplyScalar(5).add(n); return function (e, t, r = !1) { Nt(t); let n = []; for (let o = 0; o < t.length - 1; o++) { let i = t[o], l = t[o + 1], s = Kt(e[0], e[1], i, l); if (null != s && null != s && (n.push(s), r)) break } return n }([rr(n), rr(i)], r, !0)[0] } function _e(e, t) { let r = []; for (let n = 0; n < e.length; n++) { let o = t; try { Tt(e[n]); let t = u.data(e[n]).arcSegments(3).offsetLines(o); t.length; let i = 0; for (let e = 1; e < t.length; e++)t[e].length > t[i].length && (i = e); let l = Mr(t[i], .001); Tt(l), r.push(l) } catch (e) { } } return r } let De = .01; function qe(e, t, r) { return e <= r && e >= t } function Ve(e, t, r) { let n, o, i, l, s, a, h, u, c = new dt(0), f = e.bL, d = e.tR, p = e.center, g = d.x - f.x, y = d.y - f.y; switch (Pt(e.poly, c, 0, "bg"), t) { case "qCircle": n = e.tL, a = Qt(32, g - .001, n, O, 0, O, _, r, p), Pt(a, c, 0, "obj"); break; case "tri": o = rr(e.tL.clone().rotateAround(p, r)), i = rr(e.tR.clone().rotateAround(p, r)), l = rr(e.bR.clone().rotateAround(p, r)), s = rr(e.tL.clone().rotateAround(p, r)), a = [o, i, l, s], Pt(a, c, 0, "obj"); break; case "tallTri": o = rr(e.tL.clone().rotateAround(p, r)), i = rr(e.tR.clone().rotateAround(p, r)), l = rr(e.bR.clone().lerp(f, .5).rotateAround(p, r)), s = rr(e.tL.clone().rotateAround(p, r)), a = [o, i, l, s], Pt(a, c, 0, "obj"); break; case "halfCircles": a = Qt(8, .5 * g - .001, p.clone().add(fr(.5 * g, 0)), O, 0, O, _), h = Qt(8, .5 * g - .001, p.clone().add(fr(-.5 * g, 0)), O, 0, O, _), St(a, r, p, !1), St(h, r, p, !1), Pt(a, c, 0, "obj"), Pt(h, c, 0, "obj"); break; case "diagonal": a = Jt(fr(2 * g, .04), p, r + .25 * F), Pt(a, c, 0, "obj"); break; case "straight": a = Jt(fr(2 * g, .04), p, r), Pt(a, c, 0, "obj"); break; case "x": a = Jt(fr(2 * g, .04), p, r + .25 * F), h = Jt(fr(2 * g, .04), p, r + .75 * F); let t = kt([a, h]); t.length > 0 ? Pt(t[0], c, 0, "obj") : (Pt(a, c, 0, "obj"), Pt(h, c, 0, "obj")); break; case "plus": a = Jt(fr(2 * g, .04), p, r), h = Jt(fr(2 * g, .04), p, r + .5 * F); let d = kt([a, h]); d.length > 0 ? Pt(d[0], c, 0, "obj") : (Pt(a, c, 0, "obj"), Pt(h, c, 0, "obj")); break; case "lines": let v = p.clone().sub(fr(.5 * g, 0)), x = fr(g / 4, 0); a = Jt(fr(g / 8, y), v.add(x), 0), h = Jt(fr(g / 8, y), v.add(x), 0), u = Jt(fr(g / 8, y), v.add(x), 0), St(a, r, p, !1), St(h, r, p, !1), St(u, r, p, !1), Pt(a, c, 0, "obj"), Pt(h, c, 0, "obj"), Pt(u, c, 0, "obj"); break; case "circle": a = Qt(24, .5 * g - .001, p, O, 0, O, _), Pt(a, c, 0, "obj") }return c.externallyMaskWithPoly(e.poly), c.allExistingPolys } function ze(e) { let t = []; for (let r = 0; r < e.edges.length; r++)t.push([...e.edges[r]]); return { face: [...e.face], edges: t } } function je(e) { let t = null; return t = ar() < .6 ? function (e) { let t = [], r = sr(0, 6, .85), n = sr(0, 7, .85); 0 == r && 0 == n && (ar() > .5 ? r++ : n++); (1 == r && 0 == n || 1 == n && 0 == r) && ar() > .25 && (ar() > .5 ? r++ : n++); let o = .0015, i = e + o, l = gt(1), s = l[1].x - l[3].x, a = l[1].y - l[3].y, h = ar(-.25, .25) * F, u = ar(-.25, .25) * F; ar() < .15 && (h = 0); ar() < .15 && (u = 0); let c = s / (r + 1), f = !1, d = 5; 1 != subIdInt && subIdInt != ne || (d = .5); let p = .1; for (let e = 0; e < r; e++) { if (!(ar() < p && r > 1 && !f)) { let r = fr(c * (e + 1) - .5 * s + ar(.4 * -c, .4 * c), 0), n = $t(fr(o, 9), r, h, d, _, 0, 0, r), l = $t(fr(i, 9), r, h, d, _, 0, 0, r); t.push({ skinny: n, thick: l, slope: h, pos: r }) } } let g = a / (n + 1), y = !1, v = 1 != subIdInt && subIdInt != ne && ar() < .5; for (let e = 0; e < n; e++) { if (!(ar() < p && n > 1 && !y)) { let r = g * (e + 1) - .5 * a; v && 1 != subIdInt && subIdInt != ne && (r += ar(.4 * -g, .4 * g)); let n = fr(0, r), l = $t(fr(9, o), n, u, d, _, 0, 0, n), s = $t(fr(9, i), n, u, d, _, 0, 0, n); t.push({ skinny: l, thick: s, slope: u, pos: n }) } } return t }(e) : function (e) { let t = [], r = sr(3, 10), n = .0015, o = e + n, i = gt(1), l = i[1].x - i[3].x, s = i[1].y - i[3].y, a = fr(ar(-1e3, 1e3), ar(-1e3, 1e3)); for (let e = 0; e < r; e++) { let e = fr(ar(.5 * -l * .8, .5 * l * .8), ar(.5 * -s * .75, .5 * s * .75)), r = 2 * yr(e, .1, 1, a) * F, i = fr(1, 0).rotateAround(O, r).normalize(), h = 5; 1 != subIdInt && subIdInt != ne || (h = .5); let u = $t(fr(n, 10), e, r, h, _, 0, O, O), c = $t(fr(o, 10), e, r, h, _, 0, O, O), f = !1; for (let r = 0; r < t.length; r++) { let n = t[r].slope.distanceTo(i), o = t[r].pos.distanceTo(e); n < .15 && o < .25 && (f = !0) } f || t.push({ skinny: u, thick: c, slope: i, pos: e }) } return t }(e), t } function Ue(e, t, r, n) { let o = er(new t3.EllipseCurve(e.x, e.y, t, t, 0, 1.9 * Math.PI, !1, n + F).getPoints(Math.floor(500 * t))), i = null; try { let e = u.data(o).arcSegments(3).offsetLines(r); e.length; let t = Mr(e[0], .002); Tt(t), i = t } catch (e) { } return i } function He(e, t, r) { let n = [], o = 0; for (let i = 0; i < e.length; i++) { let l = { ramp: null, roundabout: null }, s = ar(t, r); try { let t = u.data(e[i]).arcSegments(3).offsetLines(s); if (t.length > 1) continue; let r = Mr(t[0], .001); if (Tt(r), l.ramp = r, ar() < .1 && o < 2) { let t = Math.floor(e[i].length / 2), r = ar(.07, .14), n = tr(e[i][t]), a = tr(e[i][t + 1]), h = tr(e[i][t - 1]), u = a.clone().sub(h); u.set(u.y, -u.x), u.normalize(); let c = Math.atan2(u.y, u.x); u.multiplyScalar(r + .1 * s), n.add(u); let f = null; f = ar() < .2 ? Ue(n, r, s, c) : Qt(24, r, n, O, 0, O), null != f && (o++, l.roundabout = f) } n.push(l) } catch (e) { } } return n } function Xe(e, t, r) { var n = fr(); return n.x = e[0] + r * (t[0] - e[0]), n.y = e[1] + r * (t[1] - e[1]), n } function Ye(e) { Nt(e); let t = []; for (let r = 0; r < e.length - 1; r++) { let n = r, o = r + 1, i = r + 2; i >= e.length - 1 && (i -= e.length - 1), o >= e.length - 1 && (o -= e.length - 1); let l = e[n], s = e[o], a = e[i], h = gr(l[0], l[1], s[0], s[1]), u = gr(s[0], s[1], a[0], a[1]); if (h < .1 || u < .1) continue; let c = tr(a).clone().sub(tr(s)), f = tr(l).clone().sub(tr(s)), d = f.clone().normalize(), p = c.clone().normalize(), g = rr(d), y = rr(p), v = fr(), x = fr(); c.multiplyScalar(.5), f.multiplyScalar(.5); let b = h + u, m = ar(), w = sr(0, 4, 5); for (let e = 0; e < w; e++) { let r, n = .2 * (e + 1); v.set(d.x, d.y), v.multiplyScalar(n).add(tr(s)).add(f), x.set(p.x, p.y), x.multiplyScalar(n).add(tr(s)).add(c), g = rr(v), y = rr(x); let o = ar() < .05, i = ar() < .05; if (m > .5 || i) { r = Ge(v, Xe(g, s, ar(.3, .7)), Xe(s, y, ar(.3, .7)), x, b) } else if (m <= .5 || o) { r = Je(v, tr(s), x, b) } t.push(r) } } return t } function Je(e, t, r, n) { const o = new t3.QuadraticBezierCurve(e, t, r), i = Math.round(n / .02); let l = er(o.getPoints(i)); return 1 != subIdInt && subIdInt != ne && (l = Mr(l, .001)), l } function Ge(e, t, r, n, o) { const i = new t3.CubicBezierCurve(e, t, r, n), l = Math.round(o / .04); let s = er(i.getPoints(l)); return 1 != subIdInt && subIdInt != ne && (s = Mr(s, .001)), s } function Qe(e, t) { for (let r = 0; r < e.length; r++) { let n = tr(e[r]), o = 2 * yr(n, 1, 1, O) * F, i = fr(.15 * t, 0).rotateAround(O, o); n.add(i), e[r][0] = n.x, e[r][1] = n.y } } function $e(e, t, r, n, o) { let i = new dt(0), l = r, s = Zt(e.verts), a = 2 * Math.max(e.ww, e.hh), h = 2 * yr(e.center, .05, 1, O) * F, u = Jt(fr(a, t), e.center, h); i.addPoly(s), i.slicePolysWithPoly(Zt(u)); for (let e = 0; e < r; e++) { let r; if (r = t > 0 ? Ft(s, t) : [s], null == r || r.length <= 0) break; s = Mr(r[0], .001); let n = "translation"; e == l - 1 && (n = "lastTranslation"), Pt(s, i, 0, n), i.slicePolysWithPoly(Zt(u)) } return i.externallyMaskWithPoly(e.verts), i.allExistingPolys } function Ke(e, t, r, n, o, i, l, s) { let a = new dt(0), h = n, u = Zt(e.verts); a.addPoly(u); Math.max(e.ww, e.hh); for (let n = 0; n < h; n++) { let i = t; l && (i *= ar(.75, 1.5)); let u = fr(i * (n + 1), 0).rotateAround(O, r), d = Zt(e.verts); if (s) { Qe(d, dr().clamp((n + 1) / 6, 0, 1)) } null != o && St(d, o * F * (n + 1), e.avgCenter, !0), Lt(d, u); let p = Mt(d), g = { bL: p[3], tR: p[1] }; if (c = e, (f = g).bL.x > c.tR.x || f.tR.x < c.bL.x || f.tR.y < c.bL.y || f.bL.y > c.tR.y) break; let y = "translation"; n == h - 1 && (y = "lastTranslation"), Pt(d, a, 0, y) } var c, f; return a.externallyMaskWithPoly(e.verts), a.allExistingPolys } function Ze(e, t, r, n, o, i, l, s, a) { let h, u, c = Zt(e.verts); if (h = null != e.center.x ? e.avgCenter : fr(e.center[0], e.center[1]), u = n > 0 ? Ft(c, n) : [c], null == u || u.length <= 0) return { allExistingPolys: [e] }; let f = u[0]; if (Wt(f) < P) return { allExistingPolys: [e] }; let d = yr(h, .05, 2 * F, O), p = F - d - .5 * F, g = at(Bt(c, 2, e.avgCenter, !0, !0), d); Nt(g); let y = tr(g[0]), v = (tr(g[1]), tr(g[2])), x = tr(g[3]), b = 1 * gr(x.x, x.y, v.x, v.y), m = 1 * gr(x.x, x.y, y.x, y.y), w = Math.floor(m / t); 0 == w && (w = 1); let R = b / 1, C = fr(); C.subVectors(v, x); let E = C.clone().normalize().multiplyScalar(.5 * R), B = .5 * (m - (w - 1) * t); 0 == B && (B = .5 * t); let L = fr(); L.subVectors(y, x).normalize().multiplyScalar(t); let S = fr(); S.subVectors(y, x).normalize(), S.multiplyScalar(B); let T = new dt(0); "internal" == a ? T.addPolyNoIntersection(f, wt(f, 0, "subBG")) : T.addPolyNoIntersection(c, wt(c, 0, "subBG")); let k = x.clone(); if (k.add(S), "solid" != a) for (let e = 0; e < w; e++) { for (let e = 0; e < 1; e++)if (ar() < o) { const e = k.clone().add(E), t = $t(fr(1 * R, r), e, -d, .05, l, s, O, O, i); Nt(t), T.addPolyNoIntersection(t, wt(t, 0, "subLine")) } k.add(L) } let M = new dt; if ("internal" == a) { T.externallyMaskWithPoly(f), Pt(c, M, 0, "subBorder"), Pt(Jt(fr(2 * R, .05), e.avgCenter, p), M, 0, "subBorder"); for (let e = 0; e < T.allExistingPolys.length; e++) { let t = T.allExistingPolys[e]; M.addPolyNoIntersection(t.verts, wt(t.verts, 0, t.vars.type)) } M.externallyMaskWithPoly(e.verts) } else if ("external" == a) { T.externallyMaskWithPoly(c); for (let e = 0; e < T.allExistingPolys.length; e++) { let t = T.allExistingPolys[e]; M.addPolyNoIntersection(t.verts, wt(t.verts, 0, t.vars.type)) } M.addPolyNoIntersection(f, wt(f, 0, "subLine")), M.externallyMaskWithPoly(e.verts) } else if ("solid" == a) { Pt(c, M, 0, "subBorder"), Pt(Jt(fr(1.5 * R, .04), e.avgCenter, p), M, 0, "subBorder"), Pt(f, M, 0, "subSolid"), M.externallyMaskWithPoly(e.verts) } return M } function et(e) { let t = .015; "inverted" == Ae && (t = .04); let r = [], n = Ft(e.verts, t); if (null == n) return []; if (e.area > .03) for (let t = 0; t < n.length; t++) { if (n[t].length < 3) continue; e.verts = n[t]; let o = rt(e); for (let e = 0; e < o.length; e++) { let t = o[e]; r.push([...t]) } } return r } function tt(e, t = null, r = null) { let n = At(e), o = (e.area, yt(n[3], n[1], .3)); o.length < 1 && o.push(rr(e.center)); let i = new dt(.5); for (let e = 0; e < o.length; e++) { Pt(Qt(7, .405, fr(o[e][0], o[e][1]), fr(1, 1), .01, O), i, 0, "subzone") } return i.externallyMaskWithPoly(e.verts), i.allExistingPolys } function rt(e, t = null, r = null) { let n = At(e), o = (e.area, yt(n[3], n[1], .015)), i = new dt(0); for (let e = 0; e < o.length; e++) { let t = Qt(3, .0015, fr(o[e][0], o[e][1]), fr(1, 1), 0, O); i.addPolyNoIntersection(t, null) } return i.externallyMaskWithPoly(e.verts, 1, null, !0), i.getPlainPolys() } function nt(e) { let t = e[0][0] == e[e.length - 1][0] && e[0][1] == e[e.length - 1][1] ? 1 : 0, r = [0, 0]; for (let n = 0; n < e.length - t; n++)r[0] += e[n][0], r[1] += e[n][1]; return r[0] /= e.length - t, r[1] /= e.length - t, r } function ot() { return "lines" != Ae && "offsetLines" != Ae } let it = []; function lt(e, t = null) { let r; if (null == t) { let e = ar(); r = e < .01 ? "middle" : e < .13 ? "LoR" : e < .25 ? "ToB" : e < .45 ? "TaB" : e < .675 ? "LaR" : e < .95 ? "LaRaTaB" : "noise" } else r = t; let n, o, i, l = e[1].x, s = e[1].y, a = l * (ar() < .5 ? -1.05 : 1.05), h = s * (ar() < .5 ? -1.05 : 1.05), u = null, c = null, f = null, d = null, p = 1; if ("noise" != r) if ("LaRaTaB" != r) { if ("middle" == r) if (p = 1.5, ar() > .5) { o = fr(ar(-.2, .2), ar(.5 * e[3].y, .5 * e[0].y)), n = 1, i = fr(ar(2, 3), ar(.2, .4)) } else { let t = ar(-.2, .2); o = fr(ar(.5 * e[3].x, .5 * e[2].x), t), n = 1, i = fr(ar(.1, .2), ar(2, 3)) } else if ("ToB" == r || "TaB" == r) { o = fr(ar(e[3].x, e[2].x), h), n = 1, i = fr(ar(1, 3), .6) } else if ("LoR" == r || "LaR" == r) { o = fr(a, ar(e[3].y, e[0].y)), n = 1, i = fr(.5, ar(1, 3)) } let t = ar(.02, .1) * p; if (u = Qt(24, n, o, _, t, O, i), "LaR" == r || "TaB" == r || "LaRaTaB" == r) { if ("LaR" == r) { o = fr(-1 * a, ar(e[3].y, e[0].y)), n = 1, i = fr(.5, ar(1, 3)) } else if ("TaB" == r) { o = fr(ar(e[3].x, e[2].x), -1 * h), n = 1, i = fr(ar(1, 3), .6) } c = Qt(24, n, o, _, t, O, i) } } else { let t = ar(e[3].x, e[2].x), r = h; o = fr(t, r), n = 1, i = fr(ar(1, 3), .4); let l = ar(.02, .1); u = Qt(24, n, o, _, l, O, i), t = ar(e[3].x, e[2].x), r = -1 * h, o = fr(t, r), n = 1, i = fr(ar(1, 3), .4), c = Qt(24, n, o, _, l, O, i), t = a, r = ar(e[3].y, e[0].y), o = fr(t, r), i = fr(.4, ar(1, 4)), f = Qt(24, n, o, _, l, O, i), t = -1 * a, r = ar(e[3].y, e[0].y), o = fr(t, r), n = 1, i = fr(.4, ar(1, 4)), d = Qt(24, n, o, _, l, O, i) } else u = "noise", c = "noise", f = "noise", d = "noise"; null != u && it.push(u), null != c && it.push(c), null != f && it.push(f), null != d && it.push(d) } function st(e) { if ("noise" == it[0]) { return yr(e, .5, 1, O) > .5 } for (let t = 0; t < it.length; t++)if (It([e.x, e.y], it[t])) return !0; return !1 } function at(e, t) { let r = nt(e), n = er(Mt(St(e, t, r, !0, !0))); return St(n, -t, r, !0, !1), Tt(n), n } function ht(e) { let t = []; for (let r = 0; r < e.length; r++)t.push(fr(e[r].x, e[r].y)); return t } class ut { constructor(e, t, r) { this.rawVerts = ht(e); let n = Mt(this.rawVerts, !0); this.tL = n[0], this.tR = n[1], this.bR = n[2], this.bL = n[3], this.ww = n[1].x - n[3].x, this.hh = n[1].y - n[3].y, this.transform = t, this.rOffset = O, this.center = fr(dr().lerp(this.bL.x, this.tR.x, .5), dr().lerp(this.bL.y, this.tR.y, .5)), this.tArr = ht(e), this.utArr = ht(e); let o = t.ls, i = t.lo; null != o && 1 != o && this.setLocalScaleOfPoints(this.tArr, this.center, o); let l = t.lr; if (null != l && r > 0) if ("noise" == l) { let e = yr(this.center, .035, 2 * F, O); this.setLocalRotOfPoints(this.tArr, this.center, e) } else this.setLocalRotOfPoints(this.tArr, this.center, l); let s = t.r; 0 != s && (this.rotatePoints(this.tArr, s), this.rotatePoints(this.utArr, s)); let a = t.s; this.scalePoints(this.tArr, a), this.scalePoints(this.utArr, a); let h = t.t; this.translatePoints(this.tArr, h), this.translatePoints(this.utArr, h), null != i && 0 != i && (this.tArr = this.offsetPoints(er(this.tArr), i)), this.tArr.length > 3 && (this.tTL = this.tArr[0], this.tTR = this.tArr[1], this.tBR = this.tArr[2], this.tBL = this.tArr[3], this.utTL = this.utArr[0], this.utTR = this.utArr[1], this.utBR = this.utArr[2], this.utBL = this.utArr[3], this.tCenter = fr(dr().lerp(this.tBL.x, this.tTR.x, .5), dr().lerp(this.tBL.y, this.tTR.y, .5))), this.lowestPoint = this.getLowestPoint(), this.poly = er(this.tArr), Tt(this.poly), Nt(this.poly), this.tArea = Wt(this.poly), this.unscaledPoly = er(this.utArr), Tt(this.unscaledPoly), Nt(this.poly) } addNoiseToPoints(e, t, r) { for (let r = 0; r < e.length; r++) { let n = yr(e[r], .1, 2 * F, bt), o = (yr(e[r], .01, t, xt), fr(t, 0)); o.rotateAround(O, n), e[r].add(o) } } offsetPoints(e, t) { let r = Ft(e, t); if (null != r) { let t = 0; for (let e = 0; e < r.length; e++)Wt(r[e]) > Wt(r[t]) && (t = e); if (r[t].length > 2) { e = Mr(r[t], .005) } } return lr(e) } setLocalScaleOfPoints(e, t, r) { for (let n = 0; n < e.length; n++)e[n].sub(t), e[n].multiplyScalar(r), e[n].add(t) } setLocalRotOfPoints(e, t, r) { for (let n = 0; n < e.length; n++)e[n].sub(t), e[n].rotateAround(O, r), e[n].add(t) } translatePoints(e, t) { for (let r = 0; r < e.length; r++)e[r].add(t) } rotatePoints(e, t) { for (let r = 0; r < e.length; r++)e[r].rotateAround(O, t) } scalePoints(e, t) { for (let r = 0; r < e.length; r++)e[r].multiply(t) } getLowestPoint() { let e = this.tArr[0]; for (let t = 1; t < this.tArr.length; t++)this.tArr[t].y < e.y && (e = this.tArr[t]); return e } } function ct(e, t, r, n, o, i, l = .75, s = 1) { let a = o, h = i; if (r < s && (a = 1, h = 1), r <= n) { let u = ar() < a, c = ar() < h, f = r + 1; if (u && c) { let a = new ut([e.tL, fr(e.center.x, e.tR.y), e.center, fr(e.bL.x, e.center.y)], e.transform, r), h = new ut([fr(e.center.x, e.tL.y), e.tR, fr(e.bR.x, e.center.y), e.center], e.transform, r), u = new ut([e.center, fr(e.tR.x, e.center.y), e.bR, fr(e.center.x, e.bL.y)], e.transform, r), c = new ut([fr(e.tL.x, e.center.y), e.center, fr(e.center.x, e.bR.y), e.bL], e.transform, r); ct(a, t, f, n, o * l, i * l, l, s), ct(h, t, f, n, o * l, i * l, l, s), ct(u, t, f, n, o * l, i * l, l, s), ct(c, t, f, n, o * l, i * l, l, s) } else if (c) { let a = new ut([e.tL, fr(e.center.x, e.tR.y), fr(e.center.x, e.bR.y), e.bL], e.transform, r), h = new ut([fr(e.center.x, e.tL.y), e.tR, e.bR, fr(e.center.x, e.bL.y)], e.transform, r); ct(a, t, f, n, o * l, i * l, l, s), ct(h, t, f, n, o * l, i * l, l, s) } else if (u) { let a = new ut([e.tL, e.tR, fr(e.bR.x, e.center.y), fr(e.bL.x, e.center.y)], e.transform, r), h = new ut([fr(e.tL.x, e.center.y), fr(e.tR.x, e.center.y), e.bR, e.bL], e.transform, r); ct(a, t, f, n, o * l, i * l, l, s), ct(h, t, f, n, o * l, i * l, l, s) } else t.push(e) } else t.push(e) } class ft { constructor(e, t, r = null, n = !1) { this.verts, this.verts = n ? e : Zt(e); let o = t; null == o && (o = { colors: null, tier: 0, type: null }), this.vars = o, this.verts.length > 8 && Mr(this.verts, .001), Tt(this.verts), Nt(this.verts), this.area = null == r ? Wt(this.verts) : r, this.center = fr(), this.tL, this.tR, this.bR, this.bL, this.avgCenter, this.ww, this.hh, this.calculateBounds(), this.small = this.area < Z, this.thinAndLong = this.small && (this.ww > .12 || this.hh > .12), null == this.vars.colors && (this.vars.colors = x.getNColor(this.verts, 0, this.center)) } calculateBounds() { var e = 1e3, t = -1e3, r = 1e3, n = -1e3; this.avgCenter = fr(); for (let i = 0; i < this.verts.length; i++) { var o = this.verts[i]; 0 != i && (this.avgCenter.x += o[0], this.avgCenter.y += o[1]), e = Math.min(o[0], e), t = Math.max(o[0], t), r = Math.min(o[1], r), n = Math.max(o[1], n) } this.avgCenter.divideScalar(this.verts.length - 1), this.tL = fr(e, n), this.tR = fr(t, n), this.bR = fr(t, r), this.bL = fr(e, r), this.ww = this.tR.x - this.bL.x, this.hh = this.tR.y - this.bL.y, this.center = this.bL.clone().lerp(this.tR, .5) } } class dt {
                constructor(e) { this.allExistingPolys = [], this.likelihood = e } recalculateAllVars() { for (let e = 0; e < this.allExistingPolys.length; e++)this.allExistingPolys[e].calculateBounds(), this.allExistingPolys[e].vars.colors = x.getNColor(this.allExistingPolys[e].verts, 0, this.allExistingPolys[e].center) } addPolyNoIntersection(e, t) { let r = new ft(e, t); this.allExistingPolys.push(r) } addPoly(e, t, r = !0, n = !1) { let o = new ft(e, t); if (0 == this.allExistingPolys.length) return void (r && this.allExistingPolys.push(o)); let i = [], l = []; for (let e = 0; e < this.allExistingPolys.length; e++)this.bbsTouching(o, this.allExistingPolys[e]) ? l.push(this.allExistingPolys[e]) : i.push(this.allExistingPolys[e]); let s = [], a = !1; for (let e = 0; e < l.length; e++) { if (s.length > 1e3) { s.push(l[e]); continue } let t, r = Ct(o.verts), n = Ct(l[e].verts); try { t = PolyBool.intersect(r, n) } catch (t) { a = !0, s.push(l[e]); continue } if (t.regions.length > 0) { let t = PolyBool.difference(n, r); for (let r = 0; r < t.regions.length; r++) { let n = t.regions[r], o = Wt(n); n.length > 0 && o > P ? s.push(new ft(n, l[e].vars, o, !0)) : o < P && o > ee && te.push(n) } } else s.push(l[e]) } let h = []; r && h.push(o); let u = []; if (r && (ar() < this.likelihood || n) && !a) for (let e = 0; e < l.length; e++) { let n = []; for (let o = 0; o < h.length && !(n.length > 1e3); o++) { let i = Ct(h[o].verts), s = Ct(l[e].verts), a = null; try { a = PolyBool.intersect(i, s) } catch (t) { u.push(l[e]), n.push(h[o]); continue } if (null != a && a.regions.length > 0 && r) { for (let r = 0; r < a.regions.length; r++) { let n = a.regions[r], o = Wt(n); if (n.length > 0 && o > P) { let r = ar() > .5 ? t : l[e].vars; u.push(new ft(n, r, o, !0)) } else o < P && o > ee && te.push(n) } let r = PolyBool.difference(i, s); if (r.regions.length > 0) for (let e = 0; e < r.regions.length; e++) { let o = r.regions[e], i = Wt(o); o.length > 0 && i > P ? n.push(new ft(o, t, i, !0)) : i < P && i > ee && te.push(o) } } else r && n.push(h[o]) } h = [...n] } this.allExistingPolys = [...s], this.allExistingPolys.push(...i), this.allExistingPolys.push(...u), this.allExistingPolys.push(...h) } getPlainPolys() { let e = []; for (let t = 0; t < this.allExistingPolys.length; t++)e.push(this.allExistingPolys[t].verts); return e } bbsTouching(e, t) { return !(t.bL.x > e.tR.x || t.tR.x < e.bL.x || t.tR.y < e.bL.y || t.bL.y > e.tR.y) } externallyMaskWithPoly(e, t = 1, r = [], n = !1) { let o = Ct(e), i = []; for (let e = 0; e < this.allExistingPolys.length; e++)if (ar() <= t || !r.includes(this.allExistingPolys[e].vars.type)) { let t, r = Ct(this.allExistingPolys[e].verts); try { t = PolyBool.intersect(o, r) } catch (e) { continue } if (t.regions.length > 0) for (let r = 0; r < t.regions.length; r++) { let o = t.regions[r], l = Wt(o); n && l > 0 || l > P ? i.push(new ft(o, this.allExistingPolys[e].vars, l, !0)) : l < P && l > ee && te.push(o) } } else i.push(this.allExistingPolys[e]); this.allExistingPolys = [...i] } slicePolysWithPoly(e, t = !1, r = 0) {
                    let n = Ct(e), o = []; for (let e = 0; e < this.allExistingPolys.length; e++) {
                        let t, i = Ct(this.allExistingPolys[e].verts); try { t = PolyBool.intersect(n, i) } catch (e) { continue } if (t.regions.length > 0) {
                            for (let n = 0; n < t.regions.length; n++) { let i = t.regions[n], l = Wt(i); if (i.length > 0 && l > P) { let t = ar() < .9 ? wt(i, r) : this.allExistingPolys[e].vars, n = new ft(i, t, l, !0); o.push(n) } else l < P && l > ee && te.push(i) }
                            let l = PolyBool.difference(i, n); for (let t = 0; t < l.regions.length; t++) { let n = l.regions[t], i = Wt(n); if (n.length > 0 && i > P) { let t = ar() < .9 ? wt(n, r) : this.allExistingPolys[e].vars, l = new ft(n, t, i, !0); o.push(l) } else i < P && i > ee && te.push(n) }
                        } else o.push(this.allExistingPolys[e])
                    } this.allExistingPolys = [...o]
                } sortPolys(e, t = null) { pt(this.allExistingPolys, e, t) }
        } function pt(e, t, r = null) { "xA" == t ? e.sort(((e, t) => e.bL.x - t.bL.x)) : "xD" == t ? e.sort(((e, t) => t.bL.x - e.bL.x)) : "yA" == t ? e.sort(((e, t) => e.bL.y - t.bL.y)) : "yD" == t ? e.sort(((e, t) => t.bL.y - e.bL.y)) : "random" == t ? e.sort(((e, t) => ke(e.bL.y) - ke(t.bL.y))) : "distance" == t && e.sort(((e, t) => e.center.distanceToSquared(r) - t.center.distanceToSquared(r))) } function gt(e) { let t = 1 - G * (1 - e) / g; return [fr(-G * e, b * t), fr(G * e, b * t), fr(G * e, -b * t), fr(-G * e, -b * t)] } function yt(e, t, r) { let n = t.x - e.x, o = t.y - e.y, i = fr(.5 * (t.x + e.x), .5 * (t.y + e.y)); var l = new Xr({ shape: [n, o], radius: r, tries: 50 }).fill(); for (let e = 0; e < l.length; e++)l[e][0] -= .5 * n, l[e][1] -= .5 * o, l[e][0] += i.x, l[e][1] += i.y; return l } function vt(e, t = .05) { return Math.abs(e.x) < G + t && Math.abs(e.y) < b + t } let xt = fr(1024.644, 39582.48823), bt = fr(45.6399, 324.56641); function mt(e) { let t = yr(e, 3, 2 * F, bt), r = fr(yr(e, 6, .003, xt), 0); return r.rotateAround(O, t), e.add(r) } function wt(e, t, r = null) { return { colors: t < 0 ? x.getRandomColor() : x.getNColor(e, t), tier: t < 0 ? 0 : t, type: r } } function Pt(e, t, r, n = null, o = !0, i = !1) { t.addPoly(e, wt(e, r, n), o, i) } function Rt(e, t, r, n = !1, o = !1) { let i = fr(r, 0).rotateAround(O, t); i.x = nr(i.x, $), i.y = nr(i.y, $); fr(.1, 0).rotateAround(O, t); let l = lr(e); const s = new t3.Shape(l); let a = i.x, h = i.y; var u = new t3.Matrix4; u.set(1, 0, a, 0, 0, 1, h, 0, 0, 0, 1, 0, 0, 0, 0, 1); const c = new t3.ExtrudeGeometry(s, { steps: 1, depth: 1, bevelEnabled: !1 }); c.applyMatrix4(u), c.verticesNeedUpdate = !0; let f = []; const d = c.vertices; for (let e = 0; e < c.faces.length; e++) { const t = c.faces[e]; let r = [[d[t.a].x, d[t.a].y], [d[t.b].x, d[t.b].y], [d[t.c].x, d[t.c].y], [d[t.a].x, d[t.a].y]]; f.push(r) } let p = kt(f), g = [...e]; if (n && Lt(g, i.clone()), o) { const e = Ct(g); let t = []; for (let r = 0; r < p.length; r++) { const n = Ct(p[r]); let o = { regions: [] }; try { o = PolyBool.difference(n, e) } catch (e) { t = p; break } for (let e = 0; e < o.regions.length; e++) { let r = o.regions[e]; r.length > 0 && (Nt(r), Tt(r), t.push(r)) } } return { face: g, edges: t } } return { face: g, edges: p } } function Ct(e, t = !1) { return { regions: [e], inverted: t } } let Et = fr(); function Bt(e, t, r = null, n = !1, o = !1) { let i, l = e; o && (l = [...e]), null == r ? i = O : null == r.x ? (Et.set(r[0], r[1]), i = Et) : i = r; for (let r = 0; r < l.length; r++) { let o = e[r][0], s = e[r][1]; n && (o -= i.x, s -= i.y), o *= t, s *= t, n && (o += i.x, s += i.y), l[r] = [o, s] } if (o) return l } function Lt(e, t, r = !1, n = !1) { let o = []; for (let i = 0; i < e.length; i++) { let l = e[i][0] + t.x, s = e[i][1] + t.y; r ? n ? o.push([nr(l, $), nr(s, $)]) : e[i] = [nr(l, $), nr(s, $)] : n ? o.push([l, s]) : e[i] = [l, s] } if (n) return o } function St(e, t, r = null, n = !1, o = !1) { let i, l = e; o && (l = [...e]), null == r ? i = O : null == r.x ? (Et.set(r[0], r[1]), i = Et) : i = r; let s = fr(); for (let e = 0; e < l.length; e++)s.set(l[e][0], l[e][1]), n ? (s.sub(i), s.rotateAround(O, t), s.add(i)) : s.rotateAround(i, t), l[e] = [s.x, s.y]; if (o) return l } function Tt(e) { for (let t = 0; t < e.length; t++) { let r = nr(e[t][0], $), n = nr(e[t][1], $); e[t] = [r, n] } } function kt(e) { let t = []; for (let r = 0; r < e.length; r++) { Tt(e[r]); let n = Ct(e[r]); t.push(n) } var r, n; let o; try { for (var i = PolyBool.segments(t[0]), l = 1; l < t.length; l++) { r = PolyBool.segments(t[l]); try { n = PolyBool.combine(i, r) } catch (e) { continue } i = PolyBool.selectUnion(n) } o = PolyBool.polygon(i); for (let e = 0; e < o.regions.length; e++)Nt(o.regions[e]), Tt(o.regions[e]) } catch (e) { return [] } return o.regions } function Mt(e, t = !1) { var r, n, o, i; let l = !1, s = !1; null != e[0].x ? (r = e[0].x, n = e[0].x, o = e[0].y, i = e[0].y, s = e[0].x == e[e.length - 1].x && e[0].y == e[e.length - 1].y) : (l = !0, s = e[0][0] == e[e.length - 1][0] && e[0][1] == e[e.length - 1][1], r = e[0][0], n = e[0][0], o = e[0][1], i = e[0][1]); for (let t = s ? 1 : 0; t < e.length; t++) { var a = e[t]; r = Math.min(l ? a[0] : a.x, r), n = Math.max(l ? a[0] : a.x, n), o = Math.min(l ? a[1] : a.y, o), i = Math.max(l ? a[1] : a.y, i) } let h = fr(r, i), u = fr(n, i), c = fr(n, o), f = fr(r, o), d = fr(.5 * (f.x + u.x), .5 * (f.y + u.y)); return t ? [h, u, c, f, d] : [h, u, c, f] } function At(e) { return [e.tL, e.tR, e.bR, e.bL] } function It(e, t) { for (var r = !1, n = t[0][0], o = t[0][0], i = t[0][1], l = t[0][1], s = 1; s < t.length; s++) { var a = t[s]; n = Math.min(a[0], n), o = Math.max(a[0], o), i = Math.min(a[1], i), l = Math.max(a[1], l) } if (e[0] <= n || e[0] >= o || e[1] <= i || e[1] >= l) return !1; for (var h = 0, u = t.length - 1; h < t.length; u = h++)t[h][1] >= e[1] != t[u][1] >= e[1] && e[0] <= (t[u][0] - t[h][0]) * (e[1] - t[h][1]) / (t[u][1] - t[h][1]) + t[h][0] && (r = !r); return r } function Wt(e) { if (e.length < 3) return; let t = e; null != e[0].x && (t = er(e)); for (var r = 0, n = 0, o = t.length; n < o; n++) { r += t[n][0] * t[n == t.length - 1 ? 0 : n + 1][1] * .5, r -= t[n == t.length - 1 ? 0 : n + 1][0] * t[n][1] * .5 } return Math.abs(r) } function Nt(e) { if (e[0][0] == e[e.length - 1][0] && e[0][1] == e[e.length - 1][1]) return; let t = [e[0][0], e[0][1]]; e.push(t) } function Ft(e, t) { let r = null; if (or(e), t <= 0) return e; try { r = u.data(e).arcSegments(4).padding(t) } catch (e) { } return r } function Ot(e, t = !1, r = !1) { let n, o, i, l = e; switch (r && ("oilBorder" == e ? l = "oilSmall" : "waterColorBorder" == e ? l = "waterColorSmall" : "inverted" == e ? l = "inverted" : "spacedOut" == e ? l = "spacedOut" : "skeleton" == e ? l = "skeleton" : "messy" == e && (l = "messy")), t && ("oilBorder" == e ? l = "oilNoBorder" : "waterColorBorder" == e ? l = "waterColorNoBorder" : "inverted" == e || "spacedOut" == e ? l = "oilNoBorder" : "skeleton" == e ? l = "skeleton" : "messy" == e && (l = "oilNoBorder")), l) { case "oilBorder": o = "normal", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 2.5, borderPosition: 0, borderThickness: 3, shapeMask: !0, enableShading: !0 }; break; case "waterColorBorder": o = "waterColor", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 4, borderPosition: 2, borderThickness: 0, shapeMask: !0, enableShading: !0 }; break; case "oilNoBorder": o = "normal", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 10, borderPosition: 0, borderThickness: 0, shapeMask: !0, enableShading: !1 }; break; case "oilSmall": o = "normal", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 2, borderPosition: 0, borderThickness: 0, shapeMask: !0, enableShading: !1 }; break; case "waterColorNoBorder": o = "waterColor", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 20, borderPosition: 0, borderThickness: 0, shapeMask: !0, enableShading: !1 }; break; case "waterColorSmall": o = "waterColor", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 2, borderPosition: 0, borderThickness: 0, shapeMask: !0, enableShading: !1 }; break; case "sigThin": o = "sigThin", i = j[o].brushWidth, n = { fillMode: "path", brushType: o, fillPosition: 0, borderPosition: 0, borderThickness: 0, shapeMask: !1, enableShading: !1, colors: [cr(10, 10, 10), cr(10, 10, 10)] }; break; case "sigThick": o = "sigThick", i = j[o].brushWidth, n = { fillMode: "path", brushType: o, fillPosition: 0, borderPosition: 0, borderThickness: 0, shapeMask: !1, enableShading: !1, colors: [cr(10, 10, 10), cr(10, 10, 10)] }; break; case "inverted": o = "normal", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: -50, borderPosition: -13, borderThickness: 36, shapeMask: !0, enableShading: !0 }; break; case "lines": o = "thin", i = j[o].brushWidth, n = { fillMode: "lines", brushType: o, fillPosition: 0, borderPosition: 0, borderThickness: 0, shapeMask: !1, enableShading: !1, offset: A, angle: M }; break; case "messy": o = "messy", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: 20, borderPosition: 18, borderThickness: 0, shapeMask: !0, enableShading: !1 }; break; case "spacedOut": o = "normal", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: -7, borderPosition: -10, borderThickness: 5, shapeMask: !0, enableShading: !0 }; break; case "skeleton": o = "normal", i = j[o].brushWidth, n = { fillMode: "offset", brushType: o, offset: .6 * -i, initOffset: 0, max: 100, fillPosition: -2048, borderPosition: -20, borderThickness: 12, shapeMask: !0, enableShading: !0 }; break; case "outline": o = "thin", i = j[o].brushWidth, n = { fillMode: "path", brushType: o, offset: -i, initOffset: 0, max: 100, fillPosition: -2048, borderPosition: 0, borderThickness: 10, shapeMask: !1, enableShading: !1 }; break; case "tiny": o = "sortOfThin", i = j[o].brushWidth, n = { fillMode: "path", brushType: o, fillPosition: 0, borderPosition: 0, borderThickness: 0, shapeMask: !1, enableShading: !1 } }return n } function _t() { let e = G / b, t = window.innerHeight; window.innerWidth / t > e ? (s.domElement.style.width = "auto", s.domElement.style.height = "100%") : (s.domElement.style.width = "100%", s.domElement.style.height = "auto") } let Dt = 0, qt = 1, Vt = !1, zt = 0, jt = !1, Ut = 10; let Ht = !1; function Xt(e) { if (!e && !jt) return void window.alert("Please wait for rendering to finish before saving the image."); Ht = !0; let t = de.toString(), r = 6 - t.length, n = ""; for (let e = 0; e < r; e++)n += "0"; let o = n + t + "_", l = Dt.toString(); r = 6 - l.length, n = ""; for (let e = 0; e < r; e++)n += "0"; let a = n + l, h = document.createElement("a"); h.setAttribute("download", a + fe + "_" + x.fullPalette.name + "_" + d + "_ " + o + pe + "_" + tokenData.hash + ".png"); let u = fr(y, v); "skeleton" != Ae ? (R.render(E.scene, i), C.render(B.scene, i), L.render(S.scene, i, !0)) : (R.render(E.scene, i), C.render(B.scene, i, !0)), s.domElement.toBlob((function (t) { let r = URL.createObjectURL(t); const n = document.createElement("canvas"), o = n.getContext("2d"); o.canvas.width = u.x, o.canvas.height = u.y, o.fillRect(0, 0, o.canvas.width, o.canvas.height); const i = new Image; i.onload = function () { o.drawImage(i, 0, 0, u.x, u.y); let t = n.toDataURL("image/png").replace("image/png", "image/octet-stream"); h.setAttribute("href", t), h.click(), n.remove(), h.remove(), e && setTimeout((function () { T.dispose(), k.dispose(), C.dispose(), R.dispose(), L.dispose(); let e = (parseInt(Me.e) + 1).toString(); window.location.href = "http://127.0.0.1:8080/?e=" + e }), 2e3) }, i.src = r })) } function Yt(e, t, r) { const n = e, o = e, i = new Uint8Array(n * o * (r > 1 ? 4 : 1)), l = 1e3; let s = 0, a = [], h = []; for (let e = 0; e < r; e++)a.push(ar(-l, l)), h.push(ar(-l, l)); let u = fr(); fr(1, 1); for (let e = 0; e < o; e++)for (let l = 0; l < n; l++)for (let c = 0; c < r; c++) { let r = 0; u.set((l / (n - 1) * 2 - 1) * t + a[c], (e / (o - 1) * 2 - 1) * t + h[c]), r = Vr(u.x, u.y), i[s++] = 128 * r + 128 } let c = t3.RedFormat; r > 1 && (c = t3.RGBAFormat); let f = new t3.DataTexture(i, n, o, c); return f.format = c, f.wrapS = t3.MirroredRepeatWrapping, f.wrapT = t3.MirroredRepeatWrapping, f.minFilter = t3.LinearFilter, f.magFilter = t3.LinearFilter, f.unpackAlignment = 1, f.needsUpdate = !0, f } function Jt(e, t, r) { let n = [], o = .5 * e.x, i = .5 * e.y, l = fr(-o, i).rotateAround(O, r).add(t), s = fr(o, i).rotateAround(O, r).add(t), a = fr(o, -i).rotateAround(O, r).add(t), h = fr(-o, -i).rotateAround(O, r).add(t); return n.push([l.x, l.y], [s.x, s.y], [a.x, a.y], [h.x, h.y], [l.x, l.y]), n } function Gt(e, t, r) { let n = []; for (let o = 0; o < e.length; o += 2) { let i = nr((e[o + 0] - 1500) * t + r.x, $), l = nr((e[o + 1] - 1400) * -t + r.y, $); n.push([i, l]) } return n } function Qt(e, t, r, n, o, i, l = _, s = -1, a = null, h = !0) { let u = 2 * F / e, c = [], f = -1 == s ? ar(0, 20 * F) : s; for (let d = 0; d < e; d++) { let e = fr(t, 0); if (e.rotateAround(O, u * d + f), e.multiply(l), e.add(r), null != a && e.rotateAround(a, s), o > 0) if (h) e.add(vr(e, n, o, i)); else { let t = fr(o, 0); t.rotateAround(O, 2 * yr(e, n.x, 1, i) * F), e.add(t) } c.push([e.x, e.y]) } return c.push([c[0][0], c[0][1]]), c } function $t(e, t, r, n, o, i, l, s = O, a = !0) { let h = [], u = .5 * e.x, c = .5 * e.y, f = fr(-u, c), d = fr(u, c), p = fr(u, -c), g = fr(-u, -c), y = fr(); for (let e = f.x; e < d.x; e += n) { if (y.set(e, d.y), y.rotateAround(s, r).add(t), i > 0) if (a) y.add(vr(y, o, i, l)); else { let e = .1 * Math.round(10 * yr(y, o.x, 1, O)) * 2 * F, t = fr(1, 0).rotateAround(O, e).multiplyScalar(i); y.add(t) } h.push([y.x, y.y]) } for (let e = d.y; e > p.y; e -= n) { if (y.set(p.x, e), y.rotateAround(s, r).add(t), i > 0) if (a) y.add(vr(y, o, i, l)); else { let e = .1 * Math.round(10 * yr(y, o.x, 1, O)) * 2 * F, t = fr(1, 0).rotateAround(O, e).multiplyScalar(i); y.add(t) } h.push([y.x, y.y]) } for (let e = p.x; e > g.x; e -= n) { if (y.set(e, g.y), y.rotateAround(s, r).add(t), i > 0) if (a) y.add(vr(y, o, i, l)); else { let e = .1 * Math.round(10 * yr(y, o.x, 1, O)) * 2 * F, t = fr(1, 0).rotateAround(O, e).multiplyScalar(i); y.add(t) } h.push([y.x, y.y]) } for (let e = g.y; e < f.y; e += n) { if (y.set(f.x, e), y.rotateAround(s, r).add(t), i > 0) if (a) y.add(vr(y, o, i, l)); else { let e = .1 * Math.round(10 * yr(y, o.x, 1, O)) * 2 * F, t = fr(1, 0).rotateAround(O, e).multiplyScalar(i); y.add(t) } h.push([y.x, y.y]) } return Nt(h), h } function Kt(e, t, r, n) { const o = e, i = t, l = r, s = n, a = i[0] - o[0], h = i[1] - o[1], u = s[0] - l[0], c = s[1] - l[1], f = a * c - u * h; if (0 == f) return; const d = o[0] - l[0], p = o[1] - l[1], g = a * p - h * d; if (g < 0 == f > 0) return; const y = u * p - c * d; if (y < 0 == f > 0) return; if (g > f == f > 0 || y > f == f > 0) return; const v = y / f; return [nr(o[0] + v * a, $), nr(o[1] + v * h, $)] } function Zt(e) { let t = []; for (let r = 0; r < e.length; r++)t.push([e[r][0], e[r][1]]); return t } function er(e) { let t = []; for (let r = 0; r < e.length; r++)t.push([e[r].x, e[r].y]); return t } function tr(e) { return fr(e[0], e[1]) } function rr(e) { return [e.x, e.y] } function nr(e, t) { var r = Math.pow(10, t || 0); return Math.round(e * r) / r } function or(e) { for (let t = 0; t < e.length - 1; t++)e[t][0] += ar(-.0015, .0015), e[t][1] += ar(-.0015, .0015); e[e.length - 1][0] = e[0][0], e[e.length - 1][1] = e[0][1] } function ir(e) { let t, r = e.length; for (; 0 != r;)t = Math.floor(ar(0, 1) * r), r--, [e[r], e[t]] = [e[t], e[r]]; return e } function lr(e) { let t = []; for (let r = 0; r < e.length; r++)t.push(fr(e[r][0], e[r][1])); return t } function sr(e, t, r) { return Math.floor(ar(e, t - 1e-6, r)) } function ar(e = 0, t = 1, r = 1) { let n = h.random_dec(); return Math.pow(n, r) * (t - e) + e } function hr(e = 0, t = 0, r = 0) { return new t3.Color(e, t, r) } function ur(e = 0) { return new t3.Color(e) } function cr(e = 0, t = 0, r = 0) { return new t3.Vector3(e, t, r) } function fr(e = 0, t = 0) { return new t3.Vector2(e, t) } function dr() { return t3.Math } function pr() { return ar(0, 100) } function gr(e, t, r, n) { let o = r - e, i = n - t; return Math.sqrt(i * i + o * o) } function yr(e, t, r, n) { let o = V.set(e.x, e.y).multiplyScalar(t); return o.add(fr(n.x + m.x, n.y + m.y)), Vr(o.x, o.y) * r } function vr(e, t, r, n) { let o = e, i = 1e-5, l = o.x + n.x + m.x, s = o.y + n.y + m.y; l *= t.x, s *= t.y; var a = Vr(l + i, s), h = Vr(l - i, s), u = (a - h) / (2 * i); return fr(((a = Vr(l, s + i)) - (h = Vr(l, s - i))) / (2 * i), -u).rotateAround(O, w).multiplyScalar(r) } class xr { constructor(e) { this.colors = e } } class br { constructor() { let e = ar(), t = e < .01 ? 0 : e < .03 ? 1 : e < .06 ? 2 : e < .1 ? 3 : e < .14 ? 4 : e < .22 ? 5 : e < .3 ? 6 : e < .38 ? 7 : e < .47 ? 8 : e < .57 ? 9 : e < .66 ? 10 : e < .76 ? 11 : e < .86 ? 12 : 13; this.fullPalette = we[t]; let r = ar(); this.nColorMode = r < .7 ? "normal" : r < .8 ? "vertical" : r < .9 ? "horizontal" : "high", this.hardColors = !0, this.fullPalette.colors.length < 6 && this.addColorsToPalette(), ir(this.fullPalette.colors), this.currentSubPalettes = [] } addColorsToPalette() { let e = []; for (let t = 0; t < this.fullPalette.colors.length; t++) { let r = Cr(this.fullPalette.colors[t], .35, .1).getHex(); e.push(r) } this.fullPalette.colors.push(...e) } splitPalette(e) { this.currentSubPalettes = []; let t = [], r = [...this.fullPalette.colors]; for (let n = 0; n < e; n++) { let e = r.length - 1, n = new t3.Color(r[e]); r.splice(e, 1), e = r.length - 1; let o = new t3.Color(r[e]); r.splice(e, 1), t.push([n, o]) } for (let n = 0; n < e; n++) { for (let e = 0; e < r.length; e++) { let o, i = r[e]; o = new t3.Color(i), t[n].push(o) } this.currentSubPalettes.push(new xr(t[n])) } } getColorWithType(e) { return this.currentSubPalettes[e].getColor() } getRandomColor() { return this.currentSubPalettes[0].colors[sr(0, this.currentSubPalettes[0].colors.length)] } getNColor(e, t, r = null) { let n; n = null == r ? fr(e[0][0], e[0][1]) : fr(r.x, r.y); let o = O.clone(); d && o.add(fr(338.7221, 9928.1124)); let i = o.clone().add(fr(994.23344, 39485.665)); "normal" == x.nColorMode || ("vertical" == x.nColorMode ? (n.x *= 2, n.y *= .5) : "horizontal" == x.nColorMode ? (n.x *= .5, n.y *= 2) : "high" == x.nColorMode ? (n.x *= 2, n.y *= 2) : "low" == x.nColorMode && (n.x *= .5, n.y *= .5)); let l, s = dr().clamp(.5 * yr(n, .75, 1, o) + .5 + ar(-0, 0), 0, 1), a = dr().clamp(.5 * yr(n, .75, 1, i) + .5 + ar(-0, 0), 0, 1), h = Pr(this.currentSubPalettes[t].colors, s), u = new t3.Color(h.r, h.g, h.b); if (ar() < .5) { let e = Pr(this.currentSubPalettes[t].colors, a); l = Br(new t3.Color(e.r, e.g, e.b), .05) } else l = Br(u, .1); return [Er(u, .3, .08), l] } } let mr = hr(), wr = (hr(1, 1, 1), hr(.1, .1, .1)); function Pr(e, t) { let r = (t = dr().clamp(t, 0, .99999)) / (1 / (e.length - 1)), n = Math.floor(r), o = r - n; return null == e[n] || null == e[n + 1] ? wr : (mr.setRGB(e[n].r, e[n].g, e[n].b), o = x.hardColors ? 1 * Math.round(1 * o) : .25 * Math.round(4 * o), mr.lerp(e[n + 1], o), mr) } function Rr(e, t = .2) { return Br(ur(e), t) } function Cr(e, t, r) { return Er(ur(e), t, r) } function Er(e, t = .3, r = .1) { let n = { h: 0, s: 0, l: 0 }; e.getHSL(n); let o, i, l, s = n.l < 1 - t, a = n.l > t, h = .9; return ar() < .25 && (h = .6), s && a ? (o = n.h, i = dr().clamp(n.s * ar(h, 1.05), 0, 1), l = dr().clamp(n.l + ar(.5 * -r, .5 * r), 0, 1)) : s ? (o = n.h, i = dr().clamp(n.s * ar(h, 1.05), 0, 1), l = dr().clamp(n.l + ar(.25 * -r, .75 * r), 0, 1)) : a && (o = n.h, i = dr().clamp(n.s * ar(h, 1.05), 0, 1), l = dr().clamp(n.l + ar(.75 * -r, .25 * r), 0, 1)), e.setHSL(o, i, l) } function Br(e, t = .2) { let r = { h: 0, s: 0, l: 0 }; e.getHSL(r); let n = r.h, o = dr().clamp(r.s + ar(0, .05), 0, 1), i = dr().clamp(r.l - t, 0, 1); return hr().setHSL(n, o, i) } function Lr(e, t = .2) { return function (e, t = .2) { let r = e, n = { h: 0, s: 0, l: 0 }; r.getHSL(n); let o = n.h, i = dr().clamp(n.s + ar(-.02, .02), 0, 1), l = dr().clamp(n.l + t, 0, 1); return hr().setHSL(o, i, l) }(ur(e), t) } function Sr(e, t, r) { var n = t[0], o = t[1], i = r[0] - n, l = r[1] - o; if (0 !== i || 0 !== l) { var s = ((e[0] - n) * i + (e[1] - o) * l) / (i * i + l * l); s > 1 ? (n = r[0], o = r[1]) : s > 0 && (n += i * s, o += l * s) } return (i = e[0] - n) * i + (l = e[1] - o) * l } function Tr(e, t, r, n, o) { for (var i, l = n, s = t + 1; s < r; s++) { var a = Sr(e[s], e[t], e[r]); a > l && (i = s, l = a) } l > n && (i - t > 1 && Tr(e, t, i, n, o), o.push(e[i]), r - i > 1 && Tr(e, i, r, n, o)) } function kr(e, t) { var r = e.length - 1, n = [e[0]]; return Tr(e, 0, r, t, n), n.push(e[r]), n } function Mr(e, t, r) { if (e.length <= 2) return e; var n = void 0 !== t ? t * t : 1; return e = r ? e : function (e, t) { for (var r, n, o, i, l, s = e[0], a = [s], h = 1, u = e.length; h < u; h++)r = e[h], o = s, i = void 0, l = void 0, i = (n = r)[0] - o[0], l = n[1] - o[1], i * i + l * l > t && (a.push(r), s = r); return s !== r && a.push(r), a }(e, n), e = kr(e, n) } class Ar { static isWebGLAvailable() { try { const e = document.createElement("canvas"); return !(!window.WebGLRenderingContext || !e.getContext("webgl") && !e.getContext("experimental-webgl")) } catch (e) { return !1 } } static isWebGL2Available() { try { const e = document.createElement("canvas"); return !(!window.WebGL2RenderingContext || !e.getContext("webgl2")) } catch (e) { return !1 } } static getWebGLErrorMessage() { return this.getErrorMessage(1) } static getWebGL2ErrorMessage() { return this.getErrorMessage(2) } static getErrorMessage(e) { const t = { 1: window.WebGLRenderingContext, 2: window.WebGL2RenderingContext }; let r = "Your $0 does not seem to support WebGL2. <br> Please view Metropolis on a modern device."; const n = document.createElement("div"); return n.id = "webglmessage", n.style.fontFamily = "monospace", n.style.fontSize = "13px", n.style.fontWeight = "normal", n.style.textAlign = "center", n.style.background = "#fff", n.style.color = "#000", n.style.padding = "1.5em", n.style.width = "600px", n.style.margin = "5em auto 0", r = t[e] ? r.replace("$0", "graphics card") : r.replace("$0", "browser"), r = r.replace("$1", { 1: "WebGL", 2: "WebGL 2" }[e]), n.innerHTML = r, n } } function Ir(e, t, r) { this.x = e, this.y = t, this.z = r } Ir.prototype.dot2 = function (e, t) { return this.x * e + this.y * t }, Ir.prototype.dot3 = function (e, t, r) { return this.x * e + this.y * t + this.z * r }; var Wr = [new Ir(1, 1, 0), new Ir(-1, 1, 0), new Ir(1, -1, 0), new Ir(-1, -1, 0), new Ir(1, 0, 1), new Ir(-1, 0, 1), new Ir(1, 0, -1), new Ir(-1, 0, -1), new Ir(0, 1, 1), new Ir(0, -1, 1), new Ir(0, 1, -1), new Ir(0, -1, -1)], Nr = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], Fr = new Array(512), Or = new Array(512); let _r = function (e) { e > 0 && e < 1 && (e *= 65536), (e = Math.floor(e)) < 256 && (e |= e << 8); for (var t = 0; t < 256; t++) { var r; r = 1 & t ? Nr[t] ^ 255 & e : Nr[t] ^ e >> 8 & 255, Fr[t] = Fr[t + 256] = r, Or[t] = Or[t + 256] = Wr[r % 12] } }; var Dr = .5 * (Math.sqrt(3) - 1), qr = (3 - Math.sqrt(3)) / 6; let Vr = function (e, t) { var r, n, o = (e + t) * Dr, i = Math.floor(e + o), l = Math.floor(t + o), s = (i + l) * qr, a = e - i + s, h = t - l + s; a > h ? (r = 1, n = 0) : (r = 0, n = 1); var u = a - r + qr, c = h - n + qr, f = a - 1 + 2 * qr, d = h - 1 + 2 * qr, p = Or[(i &= 255) + Fr[l &= 255]], g = Or[i + r + Fr[l + n]], y = Or[i + 1 + Fr[l + 1]], v = .5 - a * a - h * h, x = .5 - u * u - c * c, b = .5 - f * f - d * d; return 70 * ((v < 0 ? 0 : (v *= v) * v * p.dot2(a, h)) + (x < 0 ? 0 : (x *= x) * x * g.dot2(u, c)) + (b < 0 ? 0 : (b *= b) * b * y.dot2(f, d))) }; function zr() { this.vertices = null, this.edges = null, this.cells = null, this.toRecycle = null, this.beachsectionJunkyard = [], this.circleEventJunkyard = [], this.vertexJunkyard = [], this.edgeJunkyard = [], this.cellJunkyard = [] } zr.prototype.reset = function () { if (this.beachline || (this.beachline = new this.RBTree), this.beachline.root) for (var e = this.beachline.getFirst(this.beachline.root); e;)this.beachsectionJunkyard.push(e), e = e.rbNext; this.beachline.root = null, this.circleEvents || (this.circleEvents = new this.RBTree), this.circleEvents.root = this.firstCircleEvent = null, this.vertices = [], this.edges = [], this.cells = [] }, zr.prototype.sqrt = Math.sqrt, zr.prototype.abs = Math.abs, zr.prototype. = zr. = 1e-9, zr.prototype.inv = zr.inv = 1 / zr., zr.prototype.equalWithEpsilon = function (e, t) { return this.abs(e - t) < 1e-9 }, zr.prototype.greaterThanWithEpsilon = function (e, t) { return e - t > 1e-9 }, zr.prototype.greaterThanOrEqualWithEpsilon = function (e, t) { return t - e < 1e-9 }, zr.prototype.lessThanWithEpsilon = function (e, t) { return t - e > 1e-9 }, zr.prototype.lessThanOrEqualWithEpsilon = function (e, t) { return e - t < 1e-9 }, zr.prototype.RBTree = function () { this.root = null }, zr.prototype.RBTree.prototype.rbInsertSuccessor = function (e, t) { var r, n, o; if (e) { if (t.rbPrevious = e, t.rbNext = e.rbNext, e.rbNext && (e.rbNext.rbPrevious = t), e.rbNext = t, e.rbRight) { for (e = e.rbRight; e.rbLeft;)e = e.rbLeft; e.rbLeft = t } else e.rbRight = t; r = e } else this.root ? (e = this.getFirst(this.root), t.rbPrevious = null, t.rbNext = e, e.rbPrevious = t, e.rbLeft = t, r = e) : (t.rbPrevious = t.rbNext = null, this.root = t, r = null); for (t.rbLeft = t.rbRight = null, t.rbParent = r, t.rbRed = !0, e = t; r && r.rbRed;)r === (n = r.rbParent).rbLeft ? (o = n.rbRight) && o.rbRed ? (r.rbRed = o.rbRed = !1, n.rbRed = !0, e = n) : (e === r.rbRight && (this.rbRotateLeft(r), r = (e = r).rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateRight(n)) : (o = n.rbLeft) && o.rbRed ? (r.rbRed = o.rbRed = !1, n.rbRed = !0, e = n) : (e === r.rbLeft && (this.rbRotateRight(r), r = (e = r).rbParent), r.rbRed = !1, n.rbRed = !0, this.rbRotateLeft(n)), r = e.rbParent; this.root.rbRed = !1 }, zr.prototype.RBTree.prototype.rbRemoveNode = function (e) { e.rbNext && (e.rbNext.rbPrevious = e.rbPrevious), e.rbPrevious && (e.rbPrevious.rbNext = e.rbNext), e.rbNext = e.rbPrevious = null; var t, r, n = e.rbParent, o = e.rbLeft, i = e.rbRight; if (t = o ? i ? this.getFirst(i) : o : i, n ? n.rbLeft === e ? n.rbLeft = t : n.rbRight = t : this.root = t, o && i ? (r = t.rbRed, t.rbRed = e.rbRed, t.rbLeft = o, o.rbParent = t, t !== i ? (n = t.rbParent, t.rbParent = e.rbParent, e = t.rbRight, n.rbLeft = e, t.rbRight = i, i.rbParent = t) : (t.rbParent = n, n = t, e = t.rbRight)) : (r = e.rbRed, e = t), e && (e.rbParent = n), !r) if (e && e.rbRed) e.rbRed = !1; else { var l; do { if (e === this.root) break; if (e === n.rbLeft) { if ((l = n.rbRight).rbRed && (l.rbRed = !1, n.rbRed = !0, this.rbRotateLeft(n), l = n.rbRight), l.rbLeft && l.rbLeft.rbRed || l.rbRight && l.rbRight.rbRed) { l.rbRight && l.rbRight.rbRed || (l.rbLeft.rbRed = !1, l.rbRed = !0, this.rbRotateRight(l), l = n.rbRight), l.rbRed = n.rbRed, n.rbRed = l.rbRight.rbRed = !1, this.rbRotateLeft(n), e = this.root; break } } else if ((l = n.rbLeft).rbRed && (l.rbRed = !1, n.rbRed = !0, this.rbRotateRight(n), l = n.rbLeft), l.rbLeft && l.rbLeft.rbRed || l.rbRight && l.rbRight.rbRed) { l.rbLeft && l.rbLeft.rbRed || (l.rbRight.rbRed = !1, l.rbRed = !0, this.rbRotateLeft(l), l = n.rbLeft), l.rbRed = n.rbRed, n.rbRed = l.rbLeft.rbRed = !1, this.rbRotateRight(n), e = this.root; break } l.rbRed = !0, e = n, n = n.rbParent } while (!e.rbRed); e && (e.rbRed = !1) } }, zr.prototype.RBTree.prototype.rbRotateLeft = function (e) { var t = e, r = e.rbRight, n = t.rbParent; n ? n.rbLeft === t ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, t.rbParent = r, t.rbRight = r.rbLeft, t.rbRight && (t.rbRight.rbParent = t), r.rbLeft = t }, zr.prototype.RBTree.prototype.rbRotateRight = function (e) { var t = e, r = e.rbLeft, n = t.rbParent; n ? n.rbLeft === t ? n.rbLeft = r : n.rbRight = r : this.root = r, r.rbParent = n, t.rbParent = r, t.rbLeft = r.rbRight, t.rbLeft && (t.rbLeft.rbParent = t), r.rbRight = t }, zr.prototype.RBTree.prototype.getFirst = function (e) { for (; e.rbLeft;)e = e.rbLeft; return e }, zr.prototype.RBTree.prototype.getLast = function (e) { for (; e.rbRight;)e = e.rbRight; return e }, zr.prototype.Diagram = function (e) { this.site = e }, zr.prototype.Cell = function (e) { this.site = e, this.halfedges = [], this.closeMe = !1 }, zr.prototype.Cell.prototype.init = function (e) { return this.site = e, this.halfedges = [], this.closeMe = !1, this },
            zr.prototype.createCell = function (e) { var t = this.cellJunkyard.pop(); return t ? t.init(e) : new this.Cell(e) }, zr.prototype.Cell.prototype.prepareHalfedges = function () { for (var e, t = this.halfedges, r = t.length; r--;)(e = t[r].edge).vb && e.va || t.splice(r, 1); return t.sort((function (e, t) { return t.angle - e.angle })), t.length }, zr.prototype.Cell.prototype.getNeighborIds = function () { for (var e, t = [], r = this.halfedges.length; r--;)null !== (e = this.halfedges[r].edge).lSite && e.lSite.voronoiId != this.site.voronoiId ? t.push(e.lSite.voronoiId) : null !== e.rSite && e.rSite.voronoiId != this.site.voronoiId && t.push(e.rSite.voronoiId); return t }, zr.prototype.Cell.prototype.getBbox = function () { for (var e, t, r, n = this.halfedges, o = n.length, i = 1 / 0, l = 1 / 0, s = -1 / 0, a = -1 / 0; o--;)(t = (e = n[o].getStartpoint()).x) < i && (i = t), (r = e.y) < l && (l = r), t > s && (s = t), r > a && (a = r); return { x: i, y: l, width: s - i, height: a - l } }, zr.prototype.Cell.prototype.pointIntersection = function (e, t) { for (var r, n, o, i, l = this.halfedges, s = l.length; s--;) { if (n = (r = l[s]).getStartpoint(), o = r.getEndpoint(), !(i = (t - n.y) * (o.x - n.x) - (e - n.x) * (o.y - n.y))) return 0; if (i > 0) return -1 } return 1 }, zr.prototype.Vertex = function (e, t) { this.x = e, this.y = t }, zr.prototype.Edge = function (e, t) { this.lSite = e, this.rSite = t, this.va = this.vb = null }, zr.prototype.Halfedge = function (e, t, r) { if (this.site = t, this.edge = e, r) this.angle = Math.atan2(r.y - t.y, r.x - t.x); else { var n = e.va, o = e.vb; this.angle = e.lSite === t ? Math.atan2(o.x - n.x, n.y - o.y) : Math.atan2(n.x - o.x, o.y - n.y) } }, zr.prototype.createHalfedge = function (e, t, r) { return new this.Halfedge(e, t, r) }, zr.prototype.Halfedge.prototype.getStartpoint = function () { return this.edge.lSite === this.site ? this.edge.va : this.edge.vb }, zr.prototype.Halfedge.prototype.getEndpoint = function () { return this.edge.lSite === this.site ? this.edge.vb : this.edge.va }, zr.prototype.createVertex = function (e, t) { var r = this.vertexJunkyard.pop(); return r ? (r.x = e, r.y = t) : r = new this.Vertex(e, t), this.vertices.push(r), r }, zr.prototype.createEdge = function (e, t, r, n) { var o = this.edgeJunkyard.pop(); return o ? (o.lSite = e, o.rSite = t, o.va = o.vb = null) : o = new this.Edge(e, t), this.edges.push(o), r && this.setEdgeStartpoint(o, e, t, r), n && this.setEdgeEndpoint(o, e, t, n), this.cells[e.voronoiId].halfedges.push(this.createHalfedge(o, e, t)), this.cells[t.voronoiId].halfedges.push(this.createHalfedge(o, t, e)), o }, zr.prototype.createBorderEdge = function (e, t, r) { var n = this.edgeJunkyard.pop(); return n ? (n.lSite = e, n.rSite = null) : n = new this.Edge(e, null), n.va = t, n.vb = r, this.edges.push(n), n }, zr.prototype.setEdgeStartpoint = function (e, t, r, n) { e.va || e.vb ? e.lSite === r ? e.vb = n : e.va = n : (e.va = n, e.lSite = t, e.rSite = r) }, zr.prototype.setEdgeEndpoint = function (e, t, r, n) { this.setEdgeStartpoint(e, r, t, n) }, zr.prototype.Beachsection = function () { }, zr.prototype.createBeachsection = function (e) { var t = this.beachsectionJunkyard.pop(); return t || (t = new this.Beachsection), t.site = e, t }, zr.prototype.leftBreakPoint = function (e, t) { var r = e.site, n = r.x, o = r.y, i = o - t; if (!i) return n; var l = e.rbPrevious; if (!l) return -1 / 0; var s = (r = l.site).x, a = r.y, h = a - t; if (!h) return s; var u = s - n, c = 1 / i - 1 / h, f = u / h; return c ? (-f + this.sqrt(f * f - 2 * c * (u * u / (-2 * h) - a + h / 2 + o - i / 2))) / c + n : (n + s) / 2 }, zr.prototype.rightBreakPoint = function (e, t) { var r = e.rbNext; if (r) return this.leftBreakPoint(r, t); var n = e.site; return n.y === t ? n.x : 1 / 0 }, zr.prototype.detachBeachsection = function (e) { this.detachCircleEvent(e), this.beachline.rbRemoveNode(e), this.beachsectionJunkyard.push(e) }, zr.prototype.removeBeachsection = function (e) { var t = e.circleEvent, r = t.x, n = t.ycenter, o = this.createVertex(r, n), i = e.rbPrevious, l = e.rbNext, s = [e], a = Math.abs; this.detachBeachsection(e); for (var h = i; h.circleEvent && a(r - h.circleEvent.x) < 1e-9 && a(n - h.circleEvent.ycenter) < 1e-9;)i = h.rbPrevious, s.unshift(h), this.detachBeachsection(h), h = i; s.unshift(h), this.detachCircleEvent(h); for (var u = l; u.circleEvent && a(r - u.circleEvent.x) < 1e-9 && a(n - u.circleEvent.ycenter) < 1e-9;)l = u.rbNext, s.push(u), this.detachBeachsection(u), u = l; s.push(u), this.detachCircleEvent(u); var c, f = s.length; for (c = 1; c < f; c++)u = s[c], h = s[c - 1], this.setEdgeStartpoint(u.edge, h.site, u.site, o); h = s[0], (u = s[f - 1]).edge = this.createEdge(h.site, u.site, void 0, o), this.attachCircleEvent(h), this.attachCircleEvent(u) }, zr.prototype.addBeachsection = function (e) { for (var t, r, n, o, i = e.x, l = e.y, s = this.beachline.root; s;)if ((n = this.leftBreakPoint(s, l) - i) > 1e-9) s = s.rbLeft; else { if (!((o = i - this.rightBreakPoint(s, l)) > 1e-9)) { n > -1e-9 ? (t = s.rbPrevious, r = s) : o > -1e-9 ? (t = s, r = s.rbNext) : t = r = s; break } if (!s.rbRight) { t = s; break } s = s.rbRight } var a = this.createBeachsection(e); if (this.beachline.rbInsertSuccessor(t, a), t || r) { if (t === r) return this.detachCircleEvent(t), r = this.createBeachsection(t.site), this.beachline.rbInsertSuccessor(a, r), a.edge = r.edge = this.createEdge(t.site, a.site), this.attachCircleEvent(t), void this.attachCircleEvent(r); if (!t || r) { if (t !== r) { this.detachCircleEvent(t), this.detachCircleEvent(r); var h = t.site, u = h.x, c = h.y, f = e.x - u, d = e.y - c, p = r.site, g = p.x - u, y = p.y - c, v = 2 * (f * y - d * g), x = f * f + d * d, b = g * g + y * y, m = this.createVertex((y * x - d * b) / v + u, (f * b - g * x) / v + c); return this.setEdgeStartpoint(r.edge, h, p, m), a.edge = this.createEdge(h, e, void 0, m), r.edge = this.createEdge(e, p, void 0, m), this.attachCircleEvent(t), void this.attachCircleEvent(r) } } else a.edge = this.createEdge(t.site, a.site) } }, zr.prototype.CircleEvent = function () { this.arc = null, this.rbLeft = null, this.rbNext = null, this.rbParent = null, this.rbPrevious = null, this.rbRed = !1, this.rbRight = null, this.site = null, this.x = this.y = this.ycenter = 0 }, zr.prototype.attachCircleEvent = function (e) { var t = e.rbPrevious, r = e.rbNext; if (t && r) { var n = t.site, o = e.site, i = r.site; if (n !== i) { var l = o.x, s = o.y, a = n.x - l, h = n.y - s, u = i.x - l, c = i.y - s, f = 2 * (a * c - h * u); if (!(f >= -2e-12)) { var d = a * a + h * h, p = u * u + c * c, g = (c * d - h * p) / f, y = (a * p - u * d) / f, v = y + s, x = this.circleEventJunkyard.pop(); x || (x = new this.CircleEvent), x.arc = e, x.site = o, x.x = g + l, x.y = v + this.sqrt(g * g + y * y), x.ycenter = v, e.circleEvent = x; for (var b = null, m = this.circleEvents.root; m;)if (x.y < m.y || x.y === m.y && x.x <= m.x) { if (!m.rbLeft) { b = m.rbPrevious; break } m = m.rbLeft } else { if (!m.rbRight) { b = m; break } m = m.rbRight } this.circleEvents.rbInsertSuccessor(b, x), b || (this.firstCircleEvent = x) } } } }, zr.prototype.detachCircleEvent = function (e) { var t = e.circleEvent; t && (t.rbPrevious || (this.firstCircleEvent = t.rbNext), this.circleEvents.rbRemoveNode(t), this.circleEventJunkyard.push(t), e.circleEvent = null) }, zr.prototype.connectEdge = function (e, t) { var r = e.vb; if (r) return !0; var n, o, i = e.va, l = t.xl, s = t.xr, a = t.yt, h = t.yb, u = e.lSite, c = e.rSite, f = u.x, d = u.y, p = c.x, g = c.y, y = (f + p) / 2, v = (d + g) / 2; if (this.cells[u.voronoiId].closeMe = !0, this.cells[c.voronoiId].closeMe = !0, g !== d && (o = v - (n = (f - p) / (g - d)) * y), void 0 === n) { if (y < l || y >= s) return !1; if (f > p) { if (!i || i.y < a) i = this.createVertex(y, a); else if (i.y >= h) return !1; r = this.createVertex(y, h) } else { if (!i || i.y > h) i = this.createVertex(y, h); else if (i.y < a) return !1; r = this.createVertex(y, a) } } else if (n < -1 || n > 1) if (f > p) { if (!i || i.y < a) i = this.createVertex((a - o) / n, a); else if (i.y >= h) return !1; r = this.createVertex((h - o) / n, h) } else { if (!i || i.y > h) i = this.createVertex((h - o) / n, h); else if (i.y < a) return !1; r = this.createVertex((a - o) / n, a) } else if (d < g) { if (!i || i.x < l) i = this.createVertex(l, n * l + o); else if (i.x >= s) return !1; r = this.createVertex(s, n * s + o) } else { if (!i || i.x > s) i = this.createVertex(s, n * s + o); else if (i.x < l) return !1; r = this.createVertex(l, n * l + o) } return e.va = i, e.vb = r, !0 }, zr.prototype.clipEdge = function (e, t) { var r = e.va.x, n = e.va.y, o = 0, i = 1, l = e.vb.x - r, s = e.vb.y - n, a = r - t.xl; if (0 === l && a < 0) return !1; var h = -a / l; if (l < 0) { if (h < o) return !1; h < i && (i = h) } else if (l > 0) { if (h > i) return !1; h > o && (o = h) } if (a = t.xr - r, 0 === l && a < 0) return !1; if (h = a / l, l < 0) { if (h > i) return !1; h > o && (o = h) } else if (l > 0) { if (h < o) return !1; h < i && (i = h) } if (a = n - t.yt, 0 === s && a < 0) return !1; if (h = -a / s, s < 0) { if (h < o) return !1; h < i && (i = h) } else if (s > 0) { if (h > i) return !1; h > o && (o = h) } if (a = t.yb - n, 0 === s && a < 0) return !1; if (h = a / s, s < 0) { if (h > i) return !1; h > o && (o = h) } else if (s > 0) { if (h < o) return !1; h < i && (i = h) } return o > 0 && (e.va = this.createVertex(r + o * l, n + o * s)), i < 1 && (e.vb = this.createVertex(r + i * l, n + i * s)), (o > 0 || i < 1) && (this.cells[e.lSite.voronoiId].closeMe = !0, this.cells[e.rSite.voronoiId].closeMe = !0), !0 }, zr.prototype.clipEdges = function (e) { for (var t, r = this.edges, n = r.length, o = Math.abs; n--;)t = r[n], (!this.connectEdge(t, e) || !this.clipEdge(t, e) || o(t.va.x - t.vb.x) < 1e-9 && o(t.va.y - t.vb.y) < 1e-9) && (t.va = t.vb = null, r.splice(n, 1)) }, zr.prototype.closeCells = function (e) { for (var t, r, n, o, i, l, s, a, h, u = e.xl, c = e.xr, f = e.yt, d = e.yb, p = this.cells, g = p.length, y = Math.abs; g--;)if ((t = p[g]).prepareHalfedges() && t.closeMe) { for (o = (n = t.halfedges).length, r = 0; r < o;) { if (l = n[r].getEndpoint(), a = n[(r + 1) % o].getStartpoint(), y(l.x - a.x) >= 1e-9 || y(l.y - a.y) >= 1e-9) switch (!0) { case this.equalWithEpsilon(l.x, u) && this.lessThanWithEpsilon(l.y, d): if (h = this.equalWithEpsilon(a.x, u), s = this.createVertex(u, h ? a.y : d), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; l = s; case this.equalWithEpsilon(l.y, d) && this.lessThanWithEpsilon(l.x, c): if (h = this.equalWithEpsilon(a.y, d), s = this.createVertex(h ? a.x : c, d), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; l = s; case this.equalWithEpsilon(l.x, c) && this.greaterThanWithEpsilon(l.y, f): if (h = this.equalWithEpsilon(a.x, c), s = this.createVertex(c, h ? a.y : f), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; l = s; case this.equalWithEpsilon(l.y, f) && this.greaterThanWithEpsilon(l.x, u): if (h = this.equalWithEpsilon(a.y, f), s = this.createVertex(h ? a.x : u, f), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; if (l = s, h = this.equalWithEpsilon(a.x, u), s = this.createVertex(u, h ? a.y : d), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; if (l = s, h = this.equalWithEpsilon(a.y, d), s = this.createVertex(h ? a.x : c, d), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; if (l = s, h = this.equalWithEpsilon(a.x, c), s = this.createVertex(c, h ? a.y : f), i = this.createBorderEdge(t.site, l, s), r++, n.splice(r, 0, this.createHalfedge(i, t.site, null)), o++, h) break; default: throw "Voronoi.closeCells() > this makes no sense!" }r++ } t.closeMe = !1 } }, zr.prototype.quantizeSites = function (e) { for (var t, r = this., n = e.length; n--;)(t = e[n]).x = Math.floor(t.x / r) * r, t.y = Math.floor(t.y / r) * r }, zr.prototype.recycle = function (e) { if (e) { if (!(e instanceof this.Diagram)) throw "Voronoi.recycleDiagram() > Need a Diagram object."; this.toRecycle = e } }, zr.prototype.compute = function (e, t) { var r = new Date; this.reset(), this.toRecycle && (this.vertexJunkyard = this.vertexJunkyard.concat(this.toRecycle.vertices), this.edgeJunkyard = this.edgeJunkyard.concat(this.toRecycle.edges), this.cellJunkyard = this.cellJunkyard.concat(this.toRecycle.cells), this.toRecycle = null); var n = e.slice(0); n.sort((function (e, t) { var r = t.y - e.y; return r || t.x - e.x })); for (var o, i, l, s = n.pop(), a = 0, h = this.cells; ;)if (l = this.firstCircleEvent, s && (!l || s.y < l.y || s.y === l.y && s.x < l.x)) s.x === o && s.y === i || (h[a] = this.createCell(s), s.voronoiId = a++, this.addBeachsection(s), i = s.y, o = s.x), s = n.pop(); else { if (!l) break; this.removeBeachsection(l.arc) } this.clipEdges(t), this.closeCells(t); var u = new Date, c = new this.Diagram; return c.cells = this.cells, c.edges = this.edges, c.vertices = this.vertices, c.execTime = u.getTime() - r.getTime(), this.reset(), c }; var jr = Math.PI / 3, Ur = [[0, 0], [0, -1], [-1, 0], [1, 0], [0, 1], [-1, -1], [1, -1], [-1, 1], [1, 1], [0, -2], [-2, 0], [2, 0], [0, 2], [-1, -2], [1, -2], [-2, -1], [2, -1], [-2, 1], [2, 1], [-1, 2], [1, 2]], Hr = Ur.length; function Xr(e, t) { this.width = e.shape[0], this.height = e.shape[1], this.radius = e.radius || e.minDistance, this.maxTries = Math.max(3, Math.ceil(e.tries || 30)), this.rng = ar; const r = 1e-14 * Math.max(1, Math.max(this.width, this.height) / 64 | 0); var n; this.squaredRadius = this.radius * this.radius, this.radiusPlusEpsilon = this.radius + r, this.cellSize = this.radius * Math.SQRT1_2, this.angleIncrement = 2 * Math.PI / this.maxTries, this.angleIncrementOnSuccess = jr + 2e-14, this.triesIncrementOnSuccess = Math.ceil(this.angleIncrementOnSuccess / this.angleIncrement), this.processList = [], this.samplePoints = [], this.gridShape = [Math.ceil(this.width / this.cellSize), Math.ceil(this.height / this.cellSize)], this.grid = { strideX: (n = this.gridShape)[1], data: new Uint32Array(n[0] * n[1]) } } Xr.prototype.width = null, Xr.prototype.height = null, Xr.prototype.radius = null, Xr.prototype.radiusPlusEpsilon = null, Xr.prototype.squaredRadius = null, Xr.prototype.cellSize = null, Xr.prototype.angleIncrement = null, Xr.prototype.angleIncrementOnSuccess = null, Xr.prototype.triesIncrementOnSuccess = null, Xr.prototype.maxTries = null, Xr.prototype.rng = null, Xr.prototype.processList = null, Xr.prototype.samplePoints = null, Xr.prototype.gridShape = null, Xr.prototype.grid = null, Xr.prototype.addRandomPoint = function () { return this.directAddPoint([this.rng() * this.width, this.rng() * this.height, this.rng() * Math.PI * 2, 0]) }, Xr.prototype.addPoint = function (e) { return 2 === e.length && e[0] >= 0 && e[0] < this.width && e[1] >= 0 && e[1] < this.height ? this.directAddPoint([e[0], e[1], this.rng() * Math.PI * 2, 0]) : null }, Xr.prototype.directAddPoint = function (e) { var t = [e[0], e[1]]; this.processList.push(e), this.samplePoints.push(t); var r = (e[0] / this.cellSize | 0) * this.grid.strideX + (e[1] / this.cellSize | 0); return this.grid.data[r] = this.samplePoints.length, t }, Xr.prototype.inNeighbourhood = function (e) { var t, r, n, o, i, l = this.grid.strideX, s = this.gridShape[0], a = this.gridShape[1], h = e[0] / this.cellSize | 0, u = e[1] / this.cellSize | 0; for (t = 0; t < Hr; t++)if (n = h + Ur[t][0], o = u + Ur[t][1], -1 !== (r = n < 0 || o < 0 || n >= s || o >= a ? -1 : n * l + o) && 0 !== this.grid.data[r] && (i = this.samplePoints[this.grid.data[r] - 1], Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2) < this.squaredRadius)) return !0; return !1 }, Xr.prototype.next = function () { for (var e, t, r, n; this.processList.length > 0;) { var o = this.processList.length * this.rng() | 0; for (r = (t = this.processList[o])[2], 0 === (e = t[3]) && (r += (this.rng() - .5) * jr * 4); e < this.maxTries; e++) { if ((n = [t[0] + Math.cos(r) * this.radiusPlusEpsilon, t[1] + Math.sin(r) * this.radiusPlusEpsilon, r, 0])[0] >= 0 && n[0] < this.width && n[1] >= 0 && n[1] < this.height && !this.inNeighbourhood(n)) return t[2] = r + this.angleIncrementOnSuccess + this.rng() * this.angleIncrement, t[3] = e + this.triesIncrementOnSuccess, this.directAddPoint(n); r += this.angleIncrement } if (e >= this.maxTries) { const e = this.processList.pop(); o < this.processList.length && (this.processList[o] = e) } } return null }, Xr.prototype.fill = function () { for (0 === this.samplePoints.length && this.addRandomPoint(); this.next();); return this.samplePoints }, Xr.prototype.getAllPoints = function () { return this.samplePoints }, Xr.prototype.reset = function () { var e, t = this.grid.data; for (e = 0; e < t.length; e++)t[e] = 0; this.samplePoints = [], this.processList.length = 0 }; !function e(t, r, n) { function o(l, s) { if (!r[l]) { if (!t[l]) { var a = "function" == typeof require && require; if (!s && a) return a(l, !0); if (i) return i(l, !0); var h = new Error("Cannot find module '" + l + "'"); throw h.code = "MODULE_NOT_FOUND", h } var u = r[l] = { exports: {} }; t[l][0].call(u.exports, (function (e) { var r = t[l][1][e]; return o(r || e) }), u, u.exports, e, t, r, n) } return r[l].exports } for (var i = "function" == typeof require && require, l = 0; l < n.length; l++)o(n[l]); return o }({
                1: [function (e, t, r) { var n, o = e("./lib/build-log"), i = e("./lib/epsilon"), l = e("./lib/intersecter"), s = e("./lib/segment-chainer"), a = e("./lib/segment-selector"), h = e("./lib/geojson"), u = !1, c = i(); function f(e, t, r) { var o = n.segments(e), i = n.segments(t), l = r(n.combine(o, i)); return n.polygon(l) } n = { buildLog: function (e) { return !0 === e ? u = o() : !1 === e && (u = !1), !1 !== u && u.list }, epsilon: function (e) { return c.epsilon(e) }, segments: function (e) { var t = l(!0, c, u); return e.regions.forEach(t.addRegion), { segments: t.calculate(e.inverted), inverted: e.inverted } }, combine: function (e, t) { return { combined: l(!1, c, u).calculate(e.segments, e.inverted, t.segments, t.inverted), inverted1: e.inverted, inverted2: t.inverted } }, selectUnion: function (e) { return { segments: a.union(e.combined, u), inverted: e.inverted1 || e.inverted2 } }, selectIntersect: function (e) { return { segments: a.intersect(e.combined, u), inverted: e.inverted1 && e.inverted2 } }, selectDifference: function (e) { return { segments: a.difference(e.combined, u), inverted: e.inverted1 && !e.inverted2 } }, selectDifferenceRev: function (e) { return { segments: a.differenceRev(e.combined, u), inverted: !e.inverted1 && e.inverted2 } }, selectXor: function (e) { return { segments: a.xor(e.combined, u), inverted: e.inverted1 !== e.inverted2 } }, polygon: function (e) { return { regions: s(e.segments, c, u), inverted: e.inverted } }, polygonFromGeoJSON: function (e) { return h.toPolygon(n, e) }, polygonToGeoJSON: function (e) { return h.fromPolygon(n, c, e) }, union: function (e, t) { return f(e, t, n.selectUnion) }, intersect: function (e, t) { return f(e, t, n.selectIntersect) }, difference: function (e, t) { return f(e, t, n.selectDifference) }, differenceRev: function (e, t) { return f(e, t, n.selectDifferenceRev) }, xor: function (e, t) { return f(e, t, n.selectXor) } }, "object" == typeof window && (window.PolyBool = n), t.exports = n }, { "./lib/build-log": 2, "./lib/epsilon": 3, "./lib/geojson": 4, "./lib/intersecter": 5, "./lib/segment-chainer": 7, "./lib/segment-selector": 8 }], 2: [function (e, t, r) { t.exports = function () { var e, t = 0, r = !1; function n(t, r) { return e.list.push({ type: t, data: r ? JSON.parse(JSON.stringify(r)) : void 0 }), e } return e = { list: [], segmentId: function () { return t++ }, checkIntersection: function (e, t) { return n("check", { seg1: e, seg2: t }) }, segmentChop: function (e, t) { return n("div_seg", { seg: e, pt: t }), n("chop", { seg: e, pt: t }) }, statusRemove: function (e) { return n("pop_seg", { seg: e }) }, segmentUpdate: function (e) { return n("seg_update", { seg: e }) }, segmentNew: function (e, t) { return n("new_seg", { seg: e, primary: t }) }, segmentRemove: function (e) { return n("rem_seg", { seg: e }) }, tempStatus: function (e, t, r) { return n("temp_status", { seg: e, above: t, below: r }) }, rewind: function (e) { return n("rewind", { seg: e }) }, status: function (e, t, r) { return n("status", { seg: e, above: t, below: r }) }, vert: function (t) { return t === r ? e : (r = t, n("vert", { x: t })) }, log: function (e) { return "string" != typeof e && (e = JSON.stringify(e, !1, "  ")), n("log", { txt: e }) }, reset: function () { return n("reset") }, selected: function (e) { return n("selected", { segs: e }) }, chainStart: function (e) { return n("chain_start", { seg: e }) }, chainRemoveHead: function (e, t) { return n("chain_rem_head", { index: e, pt: t }) }, chainRemoveTail: function (e, t) { return n("chain_rem_tail", { index: e, pt: t }) }, chainNew: function (e, t) { return n("chain_new", { pt1: e, pt2: t }) }, chainMatch: function (e) { return n("chain_match", { index: e }) }, chainClose: function (e) { return n("chain_close", { index: e }) }, chainAddHead: function (e, t) { return n("chain_add_head", { index: e, pt: t }) }, chainAddTail: function (e, t) { return n("chain_add_tail", { index: e, pt: t }) }, chainConnect: function (e, t) { return n("chain_con", { index1: e, index2: t }) }, chainReverse: function (e) { return n("chain_rev", { index: e }) }, chainJoin: function (e, t) { return n("chain_join", { index1: e, index2: t }) }, done: function () { return n("done") } } } }, {}], 3: [function (e, t, r) { t.exports = function (e) { "number" != typeof e && (e = 1e-10); var t = { epsilon: function (t) { return "number" == typeof t && (e = t), e }, pointAboveOrOnLine: function (t, r, n) { var o = r[0], i = r[1], l = n[0], s = n[1], a = t[0]; return (l - o) * (t[1] - i) - (s - i) * (a - o) >= -e }, pointBetween: function (t, r, n) { var o = t[1] - r[1], i = n[0] - r[0], l = t[0] - r[0], s = n[1] - r[1], a = l * i + o * s; return !(a < e) && !(a - (i * i + s * s) > -e) }, pointsSameX: function (t, r) { return Math.abs(t[0] - r[0]) < e }, pointsSameY: function (t, r) { return Math.abs(t[1] - r[1]) < e }, pointsSame: function (e, r) { return t.pointsSameX(e, r) && t.pointsSameY(e, r) }, pointsCompare: function (e, r) { return t.pointsSameX(e, r) ? t.pointsSameY(e, r) ? 0 : e[1] < r[1] ? -1 : 1 : e[0] < r[0] ? -1 : 1 }, pointsCollinear: function (t, r, n) { var o = t[0] - r[0], i = t[1] - r[1], l = r[0] - n[0], s = r[1] - n[1]; return Math.abs(o * s - l * i) < e }, linesIntersect: function (t, r, n, o) { var i = r[0] - t[0], l = r[1] - t[1], s = o[0] - n[0], a = o[1] - n[1], h = i * a - l * s; if (Math.abs(h) < e) return !1; var u = t[0] - n[0], c = t[1] - n[1], f = (s * c - a * u) / h, d = (i * c - l * u) / h, p = { alongA: 0, alongB: 0, pt: [t[0] + f * i, t[1] + f * l] }; return p.alongA = f <= -e ? -2 : f < e ? -1 : f - 1 <= -e ? 0 : f - 1 < e ? 1 : 2, p.alongB = d <= -e ? -2 : d < e ? -1 : d - 1 <= -e ? 0 : d - 1 < e ? 1 : 2, p }, pointInsideRegion: function (t, r) { for (var n = t[0], o = t[1], i = r[r.length - 1][0], l = r[r.length - 1][1], s = !1, a = 0; a < r.length; a++) { var h = r[a][0], u = r[a][1]; u - o > e != l - o > e && (i - h) * (o - u) / (l - u) + h - n > e && (s = !s), i = h, l = u } return s } }; return t } }, {}], 4: [function (e, t, r) { var n = { toPolygon: function (e, t) { function r(t) { if (t.length <= 0) return e.segments({ inverted: !1, regions: [] }); function r(t) { var r = t.slice(0, t.length - 1); return e.segments({ inverted: !1, regions: [r] }) } for (var n = r(t[0]), o = 1; o < t.length; o++)n = e.selectDifference(e.combine(n, r(t[o]))); return n } if ("Polygon" === t.type) return e.polygon(r(t.coordinates)); if ("MultiPolygon" === t.type) { for (var n = e.segments({ inverted: !1, regions: [] }), o = 0; o < t.coordinates.length; o++)n = e.selectUnion(e.combine(n, r(t.coordinates[o]))); return e.polygon(n) } throw new Error("PolyBool: Cannot convert GeoJSON object to PolyBool polygon") }, fromPolygon: function (e, t, r) { function n(e, r) { return t.pointInsideRegion([.5 * (e[0][0] + e[1][0]), .5 * (e[0][1] + e[1][1])], r) } function o(e) { return { region: e, children: [] } } r = e.polygon(e.segments(r)); var i = o(null); function l(e, t) { for (var r = 0; r < e.children.length; r++) { if (n(t, (s = e.children[r]).region)) return void l(s, t) } var i = o(t); for (r = 0; r < e.children.length; r++) { var s; n((s = e.children[r]).region, t) && (i.children.push(s), e.children.splice(r, 1), r--) } e.children.push(i) } for (var s = 0; s < r.regions.length; s++) { var a = r.regions[s]; a.length < 3 || l(i, a) } function h(e, t) { for (var r = 0, n = e[e.length - 1][0], o = e[e.length - 1][1], i = [], l = 0; l < e.length; l++) { var s = e[l][0], a = e[l][1]; i.push([s, a]), r += a * n - s * o, n = s, o = a } return r < 0 !== t && i.reverse(), i.push([i[0][0], i[0][1]]), i } var u = []; function c(e) { var t = [h(e.region, !1)]; u.push(t); for (var r = 0; r < e.children.length; r++)t.push(f(e.children[r])) } function f(e) { for (var t = 0; t < e.children.length; t++)c(e.children[t]); return h(e.region, !0) } for (s = 0; s < i.children.length; s++)c(i.children[s]); return u.length <= 0 ? { type: "Polygon", coordinates: [] } : 1 == u.length ? { type: "Polygon", coordinates: u[0] } : { type: "MultiPolygon", coordinates: u } } }; t.exports = n }, {}], 5: [function (e, t, r) {
                    var n = e("./linked-list"); t.exports = function (e, t, r) {
                        function o(e, t, n) { return { id: r ? r.segmentId() : -1, start: e, end: t, myFill: { above: n.myFill.above, below: n.myFill.below }, otherFill: null } } var i = n.create(); function l(e, r) { i.insertBefore(e, (function (n) { return function (e, r, n, o, i, l) { var s = t.pointsCompare(r, i); return 0 !== s ? s : t.pointsSame(n, l) ? 0 : e !== o ? e ? 1 : -1 : t.pointAboveOrOnLine(n, o ? i : l, o ? l : i) ? 1 : -1 }(e.isStart, e.pt, r, n.isStart, n.pt, n.other.pt) < 0 })) } function s(e, t) { var r = function (e, t) { var r = n.node({ isStart: !0, pt: e.start, seg: e, primary: t, other: null, status: null }); return l(r, e.end), r }(e, t); return function (e, t, r) { var o = n.node({ isStart: !1, pt: t.end, seg: t, primary: r, other: e, status: null }); e.other = o, l(o, e.pt) }(r, e, t), r } function a(e, t) { var n = o(t, e.seg.end, e.seg); return function (e, t) { r && r.segmentChop(e.seg, t), e.other.remove(), e.seg.end = t, e.other.pt = t, l(e.other, e.pt) }(e, t), s(n, e.primary) } function h(o, l) {
                            var s = n.create(); function h(e) { return s.findTransition((function (r) { var n, o, i, l, s, a; return (n = e, o = r.ev, i = n.seg.start, l = n.seg.end, s = o.seg.start, a = o.seg.end, t.pointsCollinear(i, s, a) ? t.pointsCollinear(l, s, a) || t.pointAboveOrOnLine(l, s, a) ? 1 : -1 : t.pointAboveOrOnLine(i, s, a) ? 1 : -1) > 0 })) } function u(e, n) { var o = e.seg, i = n.seg, l = o.start, s = o.end, h = i.start, u = i.end; r && r.checkIntersection(o, i); var c = t.linesIntersect(l, s, h, u); if (!1 === c) { if (!t.pointsCollinear(l, s, h)) return !1; if (t.pointsSame(l, u) || t.pointsSame(s, h)) return !1; var f = t.pointsSame(l, h), d = t.pointsSame(s, u); if (f && d) return n; var p = !f && t.pointBetween(l, h, u), g = !d && t.pointBetween(s, h, u); if (f) return g ? a(n, s) : a(e, u), n; p && (d || (g ? a(n, s) : a(e, u)), a(n, l)) } else 0 === c.alongA && (-1 === c.alongB ? a(e, h) : 0 === c.alongB ? a(e, c.pt) : 1 === c.alongB && a(e, u)), 0 === c.alongB && (-1 === c.alongA ? a(n, l) : 0 === c.alongA ? a(n, c.pt) : 1 === c.alongA && a(n, s)); return !1 } for (var c = []; !i.isEmpty();) {
                                var f = i.getHead(); if (r && r.vert(f.pt[0]), f.isStart) { r && r.segmentNew(f.seg, f.primary); var d = h(f), p = d.before ? d.before.ev : null, g = d.after ? d.after.ev : null; function y() { if (p) { var e = u(f, p); if (e) return e } return !!g && u(f, g) } r && r.tempStatus(f.seg, !!p && p.seg, !!g && g.seg); var v, x = y(); if (x) { var b; if (e) (b = null === f.seg.myFill.below || f.seg.myFill.above !== f.seg.myFill.below) && (x.seg.myFill.above = !x.seg.myFill.above); else x.seg.otherFill = f.seg.myFill; r && r.segmentUpdate(x.seg), f.other.remove(), f.remove() } if (i.getHead() !== f) { r && r.rewind(f.seg); continue } if (e) b = null === f.seg.myFill.below || f.seg.myFill.above !== f.seg.myFill.below, f.seg.myFill.below = g ? g.seg.myFill.above : o, f.seg.myFill.above = b ? !f.seg.myFill.below : f.seg.myFill.below; else if (null === f.seg.otherFill) v = g ? f.primary === g.primary ? g.seg.otherFill.above : g.seg.myFill.above : f.primary ? l : o, f.seg.otherFill = { above: v, below: v }; r && r.status(f.seg, !!p && p.seg, !!g && g.seg), f.other.status = d.insert(n.node({ ev: f })) } else {
                                    var m = f.status; if (null === m) throw new Error("Epsilon Issue");
                                    if (s.exists(m.prev) && s.exists(m.next) && u(m.prev.ev, m.next.ev), r && r.statusRemove(m.ev.seg), m.remove(), !f.primary) { var w = f.seg.myFill; f.seg.myFill = f.seg.otherFill, f.seg.otherFill = w } c.push(f.seg)
                                } i.getHead().remove()
                            } return r && r.done(), c
                        } return e ? { addRegion: function (e) { for (var n, o, i, l = e[e.length - 1], a = 0; a < e.length; a++) { n = l, l = e[a]; var h = t.pointsCompare(n, l); 0 !== h && s((o = h < 0 ? n : l, i = h < 0 ? l : n, { id: r ? r.segmentId() : -1, start: o, end: i, myFill: { above: null, below: null }, otherFill: null }), !0) } }, calculate: function (e) { return h(e, !1) } } : { calculate: function (e, t, r, n) { return e.forEach((function (e) { s(o(e.start, e.end, e), !0) })), r.forEach((function (e) { s(o(e.start, e.end, e), !1) })), h(t, n) } }
                    }
                }, { "./linked-list": 6 }], 6: [function (e, t, r) { t.exports = { create: function () { var e = { root: { root: !0, next: null }, exists: function (t) { return null !== t && t !== e.root }, isEmpty: function () { return null === e.root.next }, getHead: function () { return e.root.next }, insertBefore: function (t, r) { for (var n = e.root, o = e.root.next; null !== o;) { if (r(o)) return t.prev = o.prev, t.next = o, o.prev.next = t, void (o.prev = t); n = o, o = o.next } n.next = t, t.prev = n, t.next = null }, findTransition: function (t) { for (var r = e.root, n = e.root.next; null !== n && !t(n);)r = n, n = n.next; return { before: r === e.root ? null : r, after: n, insert: function (e) { return e.prev = r, e.next = n, r.next = e, null !== n && (n.prev = e), e } } } }; return e }, node: function (e) { return e.prev = null, e.next = null, e.remove = function () { e.prev.next = e.next, e.next && (e.next.prev = e.prev), e.prev = null, e.next = null }, e } } }, {}], 7: [function (e, t, r) { t.exports = function (e, t, r) { var n = [], o = []; return e.forEach((function (e) { var i = e.start, l = e.end; if (!t.pointsSame(i, l)) { r && r.chainStart(e); for (var s = { index: 0, matches_head: !1, matches_pt1: !1 }, a = { index: 0, matches_head: !1, matches_pt1: !1 }, h = s, u = 0; u < n.length; u++) { var c = (y = n[u])[0], f = (y[1], y[y.length - 1]); y[y.length - 2]; if (t.pointsSame(c, i)) { if (C(u, !0, !0)) break } else if (t.pointsSame(c, l)) { if (C(u, !0, !1)) break } else if (t.pointsSame(f, i)) { if (C(u, !1, !0)) break } else if (t.pointsSame(f, l) && C(u, !1, !1)) break } if (h === s) return n.push([i, l]), void (r && r.chainNew(i, l)); if (h === a) { r && r.chainMatch(s.index); var d = s.index, p = s.matches_pt1 ? l : i, g = s.matches_head, y = n[d], v = g ? y[0] : y[y.length - 1], x = g ? y[1] : y[y.length - 2], b = g ? y[y.length - 1] : y[0], m = g ? y[y.length - 2] : y[1]; return t.pointsCollinear(x, v, p) && (g ? (r && r.chainRemoveHead(s.index, p), y.shift()) : (r && r.chainRemoveTail(s.index, p), y.pop()), v = x), t.pointsSame(b, p) ? (n.splice(d, 1), t.pointsCollinear(m, b, v) && (g ? (r && r.chainRemoveTail(s.index, v), y.pop()) : (r && r.chainRemoveHead(s.index, v), y.shift())), r && r.chainClose(s.index), void o.push(y)) : void (g ? (r && r.chainAddHead(s.index, p), y.unshift(p)) : (r && r.chainAddTail(s.index, p), y.push(p))) } var w = s.index, P = a.index; r && r.chainConnect(w, P); var R = n[w].length < n[P].length; s.matches_head ? a.matches_head ? R ? (E(w), B(w, P)) : (E(P), B(P, w)) : B(P, w) : a.matches_head ? B(w, P) : R ? (E(w), B(P, w)) : (E(P), B(w, P)) } function C(e, t, r) { return h.index = e, h.matches_head = t, h.matches_pt1 = r, h === s ? (h = a, !1) : (h = null, !0) } function E(e) { r && r.chainReverse(e), n[e].reverse() } function B(e, o) { var i = n[e], l = n[o], s = i[i.length - 1], a = i[i.length - 2], h = l[0], u = l[1]; t.pointsCollinear(a, s, h) && (r && r.chainRemoveTail(e, s), i.pop(), s = a), t.pointsCollinear(s, h, u) && (r && r.chainRemoveHead(o, h), l.shift()), r && r.chainJoin(e, o), n[e] = i.concat(l), n.splice(o, 1) } })), o } }, {}], 8: [function (e, t, r) { function n(e, t, r) { var n = []; return e.forEach((function (e) { var o = (e.myFill.above ? 8 : 0) + (e.myFill.below ? 4 : 0) + (e.otherFill && e.otherFill.above ? 2 : 0) + (e.otherFill && e.otherFill.below ? 1 : 0); 0 !== t[o] && n.push({ id: r ? r.segmentId() : -1, start: e.start, end: e.end, myFill: { above: 1 === t[o], below: 2 === t[o] }, otherFill: null }) })), r && r.selected(n), n } var o = { union: function (e, t) { return n(e, [0, 2, 1, 0, 2, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], t) }, intersect: function (e, t) { return n(e, [0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 1, 1, 0, 2, 1, 0], t) }, difference: function (e, t) { return n(e, [0, 0, 0, 0, 2, 0, 2, 0, 1, 1, 0, 0, 0, 1, 2, 0], t) }, differenceRev: function (e, t) { return n(e, [0, 2, 1, 0, 0, 0, 1, 1, 0, 2, 0, 2, 0, 0, 0, 0], t) }, xor: function (e, t) { return n(e, [0, 2, 1, 0, 2, 0, 0, 1, 1, 0, 0, 2, 0, 1, 2, 0], t) } }; t.exports = o }, {}]
            }, {}, [1]); function Yr() { var e, t, r = 0; return Object.freeze({ enqueue(n) { const o = { value: n, next: void 0 }; t = e ? t.next = o : e = o, r++ }, dequeue() { if (e) { const t = e.value; return e = e.next, r--, t } }, peek: () => e?.value, getCount: () => r }) } !function (e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.pa ? define([], e) : ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).Offset = e() }((function () { return function e(t, r, n) { function o(l, s) { if (!r[l]) { if (!t[l]) { var a = "function" == typeof require && require; if (!s && a) return a(l, !0); if (i) return i(l, !0); throw (a = Error("Cannot find module '" + l + "'")).code = "MODULE_NOT_FOUND", a } a = r[l] = { exports: {} }, t[l][0].call(a.exports, (function (e) { var r = t[l][1][e]; return o(r || e) }), a, a.exports, e, t, r, n) } return r[l].exports } for (var i = "function" == typeof require && require, l = 0; l < n.length; l++)o(n[l]); return o }({ 1: [function (e, t) { t.exports = { ca: e("./lib/rbtree"), ka: e("./lib/bintree") } }, { "./lib/bintree": 2, "./lib/rbtree": 3 }], 2: [function (e, t) { function r(e) { this.data = e, this.right = this.left = null } function n(e) { this.c = null, this.s = e, this.size = 0 } var o = e("./treebase"); r.prototype.g = function (e) { return e ? this.right : this.left }, r.prototype.l = function (e, t) { e ? this.right = t : this.left = t }, n.prototype = new o, n.prototype.W = function (e) { if (null === this.c) return this.c = new r(e), this.size++, !0; for (var t = 0, n = null, o = this.c; ;) { if (null === o) return o = new r(e), n.l(t, o), ret = !0, this.size++, !0; if (0 === this.s(o.data, e)) return !1; t = 0 > this.s(o.data, e), n = o, o = o.g(t) } }, n.prototype.remove = function (e) { if (null === this.c) return !1; var t = new r(void 0); (l = t).right = this.c; for (var n = null, o = null, i = 1; null !== l.g(i);) { n = l; var l = l.g(i), s = this.s(e, l.data); i = 0 < s; 0 === s && (o = l) } return null !== o && (o.data = l.data, n.l(n.right === l, l.g(null === l.left)), this.c = t.right, this.size--, !0) }, t.exports = n }, { "./treebase": 4 }], 3: [function (e, t) { function r(e) { this.data = e, this.right = this.left = null, this.red = !0 } function n(e) { this.c = null, this.s = e, this.size = 0 } function o(e) { return null !== e && e.red } function i(e, t) { var r = e.g(!t); return e.l(!t, r.g(t)), r.l(t, e), e.red = !0, r.red = !1, r } function l(e, t) { return e.l(!t, i(e.g(!t), !t)), i(e, t) } var s = e("./treebase"); r.prototype.g = function (e) { return e ? this.right : this.left }, r.prototype.l = function (e, t) { e ? this.right = t : this.left = t }, n.prototype = new s, n.prototype.W = function (e) { var t = !1; if (null === this.c) this.c = new r(e), t = !0, this.size++; else { var n = new r(void 0), s = 0, a = 0, h = null, u = n, c = null, f = this.c; for (u.right = this.c; ;) { if (null === f ? (f = new r(e), c.l(s, f), t = !0, this.size++) : o(f.left) && o(f.right) && (f.red = !0, f.left.red = !1, f.right.red = !1), o(f) && o(c)) { var d = u.right === h; f === c.g(a) ? u.l(d, i(h, !a)) : u.l(d, l(h, !a)) } if (0 === (d = this.s(f.data, e))) break; a = s, s = 0 > d, null !== h && (u = h), h = c, c = f, f = f.g(s) } this.c = n.right } return this.c.red = !1, t }, n.prototype.remove = function (e) { if (null === this.c) return !1; var t = new r(void 0); (c = t).right = this.c; for (var n, s = null, a = null, h = 1; null !== c.g(h);) { var u = h; n = s; s = c; var c = c.g(h), f = this.s(e, c.data); h = 0 < f; if (0 === f && (a = c), !o(c) && !o(c.g(h))) if (o(c.g(!h))) n = i(c, h), s.l(u, n), s = n; else if (!o(c.g(!h)) && null !== (f = s.g(!u))) if (o(f.g(!u)) || o(f.g(u))) { var d = n.right === s; o(f.g(u)) ? n.l(d, l(s, u)) : o(f.g(!u)) && n.l(d, i(s, u)), (u = n.g(d)).red = !0, c.red = !0, u.left.red = !1, u.right.red = !1 } else s.red = !1, f.red = !0, c.red = !0 } return null !== a && (a.data = c.data, s.l(s.right === c, c.g(null === c.left)), this.size--), this.c = t.right, null !== this.c && (this.c.red = !1), null !== a }, t.exports = n }, { "./treebase": 4 }], 4: [function (e, t) { function r() { } function n(e) { this.V = e, this.i = [], this.f = null } r.prototype.clear = function () { this.c = null, this.size = 0 }, r.prototype.find = function (e) { for (var t = this.c; null !== t;) { var r = this.s(e, t.data); if (0 === r) return t.data; t = t.g(0 < r) } return null }, r.prototype.w = function (e) { for (var t = this.c, r = this.iterator(); null !== t;) { var n = this.s(e, t.data); if (0 === n) return r.f = t, r; r.i.push(t), t = t.g(0 < n) } return null }, r.prototype.lowerBound = function (e) { for (var t = this.c, r = this.iterator(), n = this.s; null !== t;) { var o = n(e, t.data); if (0 === o) return r.f = t, r; r.i.push(t), t = t.g(0 < o) } for (o = r.i.length - 1; 0 <= o; --o)if (0 > n(e, (t = r.i[o]).data)) return r.f = t, r.i.length = o, r; return r.i.length = 0, r }, r.prototype.upperBound = function (e) { for (var t = this.lowerBound(e), r = this.s; null !== t.data() && 0 === r(t.data(), e);)t.next(); return t }, r.prototype.min = function () { var e = this.c; if (null === e) return null; for (; null !== e.left;)e = e.left; return e.data }, r.prototype.max = function () { var e = this.c; if (null === e) return null; for (; null !== e.right;)e = e.right; return e.data }, r.prototype.iterator = function () { return new n(this) }, n.prototype.data = function () { return null !== this.f ? this.f.data : null }, n.prototype.next = function () { if (null === this.f) { var e = this.V.c; null !== e && this.S(e) } else if (null === this.f.right) do { if (e = this.f, !this.i.length) { this.f = null; break } this.f = this.i.pop() } while (this.f.right === e); else this.i.push(this.f), this.S(this.f.right); return null !== this.f ? this.f.data : null }, n.prototype.F = function () { if (null === this.f) { var e = this.V.c; null !== e && this.R(e) } else if (null === this.f.left) do { if (e = this.f, !this.i.length) { this.f = null; break } this.f = this.i.pop() } while (this.f.left === e); else this.i.push(this.f), this.R(this.f.left) }, n.prototype.S = function (e) { for (; null !== e.left;)this.i.push(e), e = e.left; this.f = e }, n.prototype.R = function (e) { for (; null !== e.right;)this.i.push(e), e = e.right; this.f = e }, t.exports = r }, {}], 5: [function (e, t) { t.exports = e("./src/index") }, { "./src/index": 10 }], 6: [function (e, t) { var r = e("./signed_area"); e("./equals"), t.exports = function (e, t) { var n = e.a, o = t.a; return n[0] > o[0] ? 1 : n[0] < o[0] ? -1 : n[1] !== o[1] ? n[1] > o[1] ? 1 : -1 : e.left !== t.left ? e.left ? 1 : -1 : 0 !== r(n, e.b.a, t.b.a) ? e.H(t.b.a) ? -1 : 1 : !e.j && t.j ? 1 : -1 } }, { "./equals": 9, "./signed_area": 12 }], 7: [function (e, t) { var r = e("./signed_area"), n = e("./compare_events"), o = e("./equals"); t.exports = function (e, t) { return e === t ? 0 : 0 !== r(e.a, e.b.a, t.a) || 0 !== r(e.a, e.b.a, t.b.a) ? o(e.a, t.a) ? e.H(t.b.a) ? -1 : 1 : e.a[0] === t.a[0] ? e.a[1] < t.a[1] ? -1 : 1 : 1 === n(e, t) ? t.ia(e.a) ? -1 : 1 : e.H(t.a) ? -1 : 1 : e.j !== t.j ? e.j ? -1 : 1 : o(e.a, t.a) ? o(e.b.a, t.b.a) ? 0 : e.m > t.m ? 1 : -1 : 1 === n(e, t) ? 1 : -1 } }, { "./compare_events": 6, "./equals": 9, "./signed_area": 12 }], 8: [function (e, t) { t.exports = { M: 0, ba: 1, N: 2, L: 3 } }, {}], 9: [function (e, t) { t.exports = function (e, t) { return e[0] === t[0] && e[1] === t[1] } }, {}], 10: [function (e, t) { function r(e, t, n, o, i) { var l, s; if ("number" == typeof e[0][0]) for (l = 0, s = e.length - 1; l < s; l++) { var a = e[l], h = e[l + 1], u = t, c = n + 1, f = o, d = i, p = new g(a, !1, void 0, u); h = new g(h, !1, p, u); p.b = h, p.m = h.m = c, 0 < y(p, h) ? h.left = !0 : p.left = !0, d[0] = w(d[0], a[0]), d[1] = w(d[1], a[1]), d[2] = m(d[2], a[0]), d[3] = m(d[3], a[1]), f.push(p), f.push(h) } else for (l = 0, s = e.length; l < s; l++)P++, r(e[l], t, P, o, i) } function n(e, t, n, o) { var i = new d(null, y); return P = 0, r(e, !0, 0, i, n), r(t, !1, 0, i, o), i } function o(e, t, r, n) { null === t ? (e.v = !1, e.u = !0) : e.j === t.j ? (e.v = !t.v, e.u = t.u) : (e.v = !t.u, e.u = t.Y() ? !t.v : t.v), t && (e.G = !i(t, n) || t.Y() ? t.G : t), e.K = i(e, n) } function i(e, t) { switch (e.type) { case f.M: switch (t) { case 0: return !e.u; case 1: return e.u; case 2: return e.j && e.u || !e.j && !e.u; case 3: return !0 }case f.N: return 0 === t || 1 === t; case f.L: return 2 === t }return !1 } function l(e, t, r) { var n = (o = x(e.a, e.b.a, t.a, t.b.a)) ? o.length : 0; if (0 === n || 1 === n && (b(e.a, t.a) || b(e.b.a, t.b.a))) return 0; if (2 === n && e.j === t.j) return 0; if (1 === n) return b(e.a, o[0]) || b(e.b.a, o[0]) || s(e, o[0], r), b(t.a, o[0]) || b(t.b.a, o[0]) || s(t, o[0], r), 1; var o = [], i = n = !1; return b(e.a, t.a) ? n = !0 : 1 === y(e, t) ? o.push(t, e) : o.push(e, t), b(e.b.a, t.b.a) ? i = !0 : 1 === y(e.b, t.b) ? o.push(t.b, e.b) : o.push(e.b, t.b), n && i || n ? (e.type = f.ba, t.type = e.v === t.v ? f.N : f.L, n && !i && s(o[0].b, o[1].a, r), 2) : i ? (s(o[0], o[1].a, r), 3) : o[0] !== o[3].b ? (s(o[0], o[1].a, r), s(o[1], o[2].a, r), 3) : (s(o[0], o[1].a, r), s(o[3].b, o[2].a, r), 3) } function s(e, t, r) { var n = new g(t, !1, e, e.j); return t = new g(t, !0, e.b, e.j), b(e.a, e.b.a) && console.warn("Sides of the same polygon overlap", e), n.m = t.m = e.m, 0 < y(t, e.b) && (e.b.left = !0, t.left = !1), e.b.b = t, e.b = n, r.push(t), r.push(n), r } function a(e, t, r, n, i, s) { var a, h; r = new p(v), t = []; let u = 0; for (i = w(n[2], i[2]); e.length;) { if (u++, u > 1e4) { console.warn("Bad bug here"); break } var c = e.pop(); if (t.push(c), 0 === s && c.a[0] > i || 2 === s && c.a[0] > n[2]) break; if (c.left) { if (r.W(c), h = r.w(c), a = r.w(c), c.iterator = r.w(c), !a || !h) { a = (d = r).iterator(), h = d.iterator(); for (var f, d = d.iterator(); null !== (f = d.next()) && (a.next(), h.next(), f !== event);); a = (h = [a, h])[0], h = h[1] } a.data() !== r.min() ? a.F() : ((a = r.iterator()).F(), a.next()), h.next(), o(c, a.data(), 0, s), h.data() && 2 === l(c, h.data(), e) && (o(c, a.data(), 0, s), o(c, h.data(), 0, s)), a.data() && 2 === l(a.data(), c, e) && ((h = r.w(a.data())).data() !== r.min() ? h.F() : (h = r.w(r.max())).next(), o(a.data(), h.data(), 0, s), o(c, a.data(), 0, s)) } else c = c.b, h = r.w(c), (a = r.w(c)) && h && (a.data() !== r.min() ? a.F() : ((a = r.iterator()).F(), a.next()), h.next(), r.remove(c), h.data() && a.data() && l(a.data(), h.data(), e)) } return t } function h(e, t) { "[object Array]" === Object.prototype.toString.call(e[0][0]) || (e = [e]), e[t] = [] } function u(e, t, r) { var o, i = null; if (0 == e.length * t.length && (0 === r ? i = c : 2 === r ? i = e : 1 !== r && 3 !== r || (i = 0 === e.length ? t : e)), o = i) return o === c ? null : o; var l = [1 / 0, 1 / 0, -1 / 0, -1 / 0], s = n(e, t, i = [1 / 0, 1 / 0, -1 / 0, -1 / 0], l); if (o = null, (i[0] > l[2] || l[0] > i[2] || i[1] > l[3] || l[1] > i[3]) && (0 === r ? o = c : 2 === r ? o = e : 1 !== r && 3 !== r || (o = e.concat(t))), o) return o === c ? null : o; for (e = [], t = 0, r = (i = a(s, 0, 0, i, l, r)).length; t < r; t++)event = i[t], (event.left && event.K || !event.left && event.b.K) && e.push(event); let u = 0; for (i = !1; !i && (u++, !(u > 2e3));) { for (i = !0, t = 0, r = e.length; t < r; t++)t + 1 < r && 1 === y(e[t], e[t + 1]) && (l = t + 1, s = (i = e)[t], i[t] = i[l], i[l] = s, i = !1); t = 0 } for (r = e.length; t < r; t++)e[t].A = t; for (t = 0, r = e.length; t < r; t++)e[t].left || (i = e[t].A, e[t].A = e[t].b.A, e[t].b.A = i); i = Array(e.length), l = [], s = [], o = []; var f = {}; for (t = 0, r = e.length; t < r; t++)if (!i[t]) { var d = []; l.push(d); var p = l.length - 1; if (s.push(0), o.push(-1), e[t].G) { var g = e[t].G.m; e[t].G.I ? f[g] && (h(l[o[g]], p), o[p] = o[g], s[p] = s[g], f[p] = !0) : (h(l[g], p), o[p] = g, s[p] = s[g] + 1, f[p] = !0) } for (g = t, d.push(e[t].a); g >= t;) { i[g] = !0, e[g].left ? (e[g].I = !1, e[g].m = p) : (e[g].b.I = !0, e[g].b.m = p), i[g = e[g].A] = !0, d.push(e[g].a); e: { for (var v = e, x = i, m = g + 1, w = v.length; m < w && b(v[m].a, v[g].a);) { if (!x[m]) { g = m; break e } m += 1 } for (m = g - 1; x[m];)--m; g = m } } i[g = -1 === g ? t : g] = i[e[g].A] = !0, e[g].b.I = !0, e[g].b.m = p, 1 & s[p] && d.reverse() } return l } var c = [], f = e("./edge_type"), d = e("tinyqueue"), p = e("bintrees").ca, g = e("./sweep_event"), y = e("./compare_events"), v = e("./compare_segments"), x = e("./segment_intersection"), b = e("./equals"), m = Math.max, w = Math.min, P = 0; t.exports = u, t.exports.union = function (e, t) { return u(e, t, 1) }, t.exports.diff = function (e, t) { return u(e, t, 2) }, t.exports.wa = function (e, t) { return u(e, t, 3) }, t.exports.intersection = function (e, t) { return u(e, t, 0) }, t.exports.ta = { ma: 0, la: 2, na: 1, oa: 3 }, t.exports.sa = n, t.exports.qa = o, t.exports.va = a, t.exports.ra = s, t.exports.ua = l }, { "./compare_events": 6, "./compare_segments": 7, "./edge_type": 8, "./equals": 9, "./segment_intersection": 11, "./sweep_event": 13, bintrees: 1, tinyqueue: 14 }], 11: [function (e, t) { function r(e, t) { return e[0] * t[1] - e[1] * t[0] } function n(e, t) { return e[0] * t[0] + e[1] * t[1] } t.exports = function (e, t, o, i, l) { function s(e, t, r) { return [e[0] + t * r[0], e[1] + t * r[1]] } t = [t[0] - e[0], t[1] - e[1]], i = [i[0] - o[0], i[1] - o[1]], o = [o[0] - e[0], o[1] - e[1]]; var a = r(t, i), h = n(t, t); if (a * a > 1e-9 * h * n(i, i)) return 0 > (i = r(o, i) / a) || 1 < i || 0 > (o = r(o, t) / a) || 1 < o || l ? null : [s(e, i, t)]; var u = n(o, o); return (a = r(o, t)) * a > 1e-9 * h * u ? null : (a = (o = n(t, o) / h) + n(t, i) / h, i = Math.min(o, a), o = Math.max(o, a), 1 >= i && 0 <= o ? 1 === i ? l ? null : [s(e, 0 < i ? i : 0, t)] : 0 === o ? l ? null : [s(e, 1 > o ? o : 1, t)] : l && 0 === i && 1 === o ? null : [s(e, 0 < i ? i : 0, t), s(e, 1 > o ? o : 1, t)] : null) } }, {}], 12: [function (e, t) { t.exports = function (e, t, r) { return (e[0] - r[0]) * (t[1] - r[1]) - (t[0] - r[0]) * (e[1] - r[1]) } }, {}], 13: [function (e, t) { function r(e, t, r, n, i) { this.left = t, this.a = e, this.b = r, this.j = n, this.type = i || o.M, this.u = this.v = !1, this.G = null, this.I = this.K = !1 } var n = e("./signed_area"), o = e("./edge_type"); r.prototype = { H: function (e) { return this.left ? 0 < n(this.a, this.b.a, e) : 0 < n(this.b.a, this.a, e) }, ia: function (e) { return !this.H(e) }, Y: function () { return this.a[0] === this.b.a[0] } }, t.exports = r }, { "./edge_type": 8, "./signed_area": 12 }], 14: [function (e, t) { function r(e, t) { if (!(this instanceof r)) return new r(e, t); if (this.data = e || [], this.length = this.data.length, this.compare = t || n, e) for (var o = Math.floor(this.length / 2); 0 <= o; o--)this.O(o) } function n(e, t) { return e < t ? -1 : e > t ? 1 : 0 } t.exports = r, r.prototype = { push: function (e) { this.data.push(e), this.length++, this.ea(this.length - 1) }, pop: function () { var e = this.data[0]; return this.data[0] = this.data[this.length - 1], this.length--, this.data.pop(), this.O(0), e }, ea: function (e) { for (var t = this.data, r = this.compare; 0 < e;) { var n = Math.floor((e - 1) / 2); if (!(0 > r(t[e], t[n]))) break; var o = t, i = o[n]; o[n] = o[e], o[e] = i, e = n } }, O: function (e) { for (var t = this.data, r = this.compare, n = this.length; ;) { var o = 2 * e + 1, i = o + 1, l = e; if (o < n && 0 > r(t[o], t[l]) && (l = o), i < n && 0 > r(t[i], t[l]) && (l = i), l === e) break; i = (o = t)[l], o[l] = o[e], o[e] = i, e = l } } } }, {}], 15: [function (e, t) { function r(e, t) { this.current = e, this.next = t, this.P = this.X(), this.T = this.ja() } r.prototype.ja = function () { var e = this.X(); return [-e[0], -e[1]] }, r.prototype.X = function () { var e = this.next[0] - this.current[0], t = this.next[1] - this.current[1], r = Math.sqrt(e * e + t * t); if (0 === r) throw Error("Vertices overlap"); return [-t / r, e / r] }, r.prototype.offset = function (e, t) { return r.Z(this.current, this.next, e, t) }, r.prototype.ha = function (e, t) { return r.Z(this.next, this.current, e, t) }, r.Z = function (e, t, n, o) { return new r([e[0] + n, e[1] + o], [t[0] + n, t[1] + o]) }, r.prototype.inverse = function () { return new r(this.next, this.current) }, t.exports = r }, {}], 16: [function (e, t) { function r(e, t) { this.h = null, this.o = 0, e && this.data(e), this.J = void 0 !== t ? t : 5 } var n = e("./edge"), o = e("martinez-polygon-clipping"), i = e("./utils"), l = i.isArray, s = i.ga, a = i.aa; r.prototype.data = function (e) { if (this.B = [], !l(e)) throw Error("Offset requires at least one coodinate to work with"); return l(e) && "number" == typeof e[0] ? this.h = e : (this.h = a(e), this.U(this.h, this.B)), this }, r.prototype.getMartinez = function () { return o }, r.prototype.U = function (e, t) { var r, o; if (l(e[0]) && "number" == typeof e[0][0]) for (o = e.length, s(e[0], e[o - 1]) && --o, r = 0; r < o; r++)t.push(new n(e[r], e[(r + 1) % o])); else for (r = 0, o = e.length; r < o; r++)t.push([]), this.U(e[r], t[t.length - 1]) }, r.prototype.arcSegments = function (e) { return this.J = e, this }, r.prototype.fa = function (e, t, r, n, o, i) { var l = 2 * Math.PI, s = Math.atan2(n[1] - t[1], n[0] - t[0]), a = Math.atan2(o[1] - t[1], o[0] - t[0]); for (0 == i % 2 && --i, 0 > s && (s += l), 0 > a && (a += l), l = -(s > a ? s - a : s + l - a) / i, e.push(n), a = 1; a < i; ++a)n = s + l * a, e.push([t[0] + Math.cos(n) * r, t[1] + Math.sin(n) * r]); e.push(o) }, r.prototype.distance = function (e) { return this.o = e || 0, this }, r.degreesToUnits = function (e, t) { switch (t) { case "miles": e /= 69.047; break; case "feet": e /= 364568; break; case "kilometers": e /= 111.12; break; case "meters": case "metres": e /= 111120 }return e }, r.prototype.C = function (e) { return s(e[0], e[e.length - 1]) || e.push([e[0][0], e[0][1]]), e }, r.prototype.offset = function (e) { return this.distance(e), 0 === this.o ? this.h : 0 < this.o ? this.margin(this.o) : this.padding(-this.o) }, r.prototype.da = function (e, t, r, n) { var o = []; r = [r.offset(r.P[0] * n, r.P[1] * n), r.ha(r.T[0] * n, r.T[1] * n)]; for (var i = 0; 2 > i; i++)this.fa(o, 0 === i ? e : t, n, r[(i + 2 - 1) % 2].next, r[i].current, this.J); return o }, r.prototype.margin = function (e) { return this.distance(e), "number" == typeof this.h[0] ? this.$(this.o) : 0 === e ? this.h : (e = this.offsetLines(this.o), e = o.union(this.h, e), a(e)) }, r.prototype.padding = function (e) { return this.distance(e), 0 === this.o ? this.C(this.h) : 2 === this.h.length && "number" == typeof this.h[0] ? this.h : (e = this.offsetLines(this.o), e = o.diff(this.h, e), a(e)) }, r.prototype.offsetLines = function (e) { if (0 > e) throw Error("Cannot apply negative margin to the line"); var t; if (this.distance(e), l(this.h[0]) && "number" != typeof this.h[0][0]) { e = 0; for (var r = this.B.length; e < r; e++)t = 0 === e ? this.D(this.h[e], this.B[e]) : o.union(t, this.D(this.h[e], this.B[e])) } else t = 1 === this.h.length ? this.$() : this.D(this.h, this.B); return t }, r.prototype.D = function (e, t) { var r, n, i; if (l(e[0]) && "number" == typeof e[0][0]) for (n = 0, i = e.length - 1; n < i; n++) { var s = this.C(this.da(e[n], e[n + 1], t[n], this.o)); r = 0 === n ? [this.C(s)] : o.union(r, this.C(s)) } else for (n = 0, i = t.length; n < i; n++)r = 0 === n ? this.D(e[n], t[n]) : o.union(r, this.D(e[n], t[n])); return r }, r.prototype.$ = function (e) { this.distance(e), e = 2 * this.J; var t = [], r = this.h, n = this.o, o = 0; 0 == e % 2 && e++; for (var i = 0; i < e; i++)o += 2 * Math.PI / e, t.push([r[0] + n * Math.cos(o), r[1] + n * Math.sin(o)]); return a([this.C(t)]) }, r.aa = a, t.exports = r }, { "./edge": 15, "./utils": 17, "martinez-polygon-clipping": 5 }], 17: [function (e, t) { var r = t.exports.isArray = Array.isArray || function (e) { return "[object Array]" === Object.prototype.toString.call(e) }; t.exports.ga = function (e, t) { return e[0] === t[0] && e[1] === t[1] }, t.exports.aa = function e(t, n, o) { var i, l; if (n = n || 0, r(t) && "number" == typeof t[0][0]) { for (i = n = 0, l = t.length; i < l; i++) { var s = t[i], a = t[(i + 1) % l]; n += s[0] * a[1], n -= a[0] * s[1] } (!o && 0 < n || o && 0 > n) && t.reverse() } else for (i = 0, l = t.length; i < l; i++)e(t[i], n + 1, 0 < i); return t } }, {}] }, {}, [16])(16) })), function () {
                if (Se = performance.now(), !1 === Ar.isWebGL2Available()) return document.body.appendChild(Ar.getWebGL2ErrorMessage()), void (jt = !0); c && function (e) { let t; e % 2 == 0 ? (tokenData.tokenId = 100, t = 0) : (tokenData.tokenId = 600, t = -1); let r = e + t, hash = "0x"; for (var n = 0; n < 64; n++)hash += Math.floor(16 * ke(r + n)).toString(16); tokenData.hash = hash }(Math.round(Me.e)); let q = Me.r, V = !1; null == q || isNaN(q) || (Y = q, V = !0); let X = Me.f, J = !1; null == X || isNaN(X) || (Ut = Math.floor(dr().clamp(X, 1, 20)), J = !0); let tokenId = tokenData.tokenId; subIdInt = tokenId % 1e6, subIdInt >= 500 ? (console.log("IRL mint: " + subIdInt), d = !0) : (d = !1, console.log("Online mint: " + subIdInt)), 0 != subIdInt && 500 != subIdInt || (tokenData.hash = Ee + Be + Le), console.log(tokenData), h = new e, _r(ar(0, 64e3)), m = fr(ar(-1e3, 1e3)), w = ar(0, 2 * F), f = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform), f && (Y = .5), y = 1800 * Y, v = 2700 * Y, g = v / y, b = g, Q = []; for (let e = 0; e < 7; e++)Q.push(ar()); if (u = new Offset, P = Math.pow(.007, 2), W = new Yr, W.enqueue(le), se += le, c) { let e = document.createElement("a"); e.href = "data:application/octet-stream," + encodeURIComponent(ce), e.download = tokenData.hash + ".txt", e.click() } x = new br, x.splitPalette(1), p = new Yr; const K = new Uint8Array(1); k = new t3.DataTexture(K, 1, 1), k.format = t3.RedFormat, k.wrapS = t3.ClampToEdgeWrapping, k.wrapT = t3.ClampToEdgeWrapping; const ee = new Uint8Array(1); ee[0] = 255, T = new t3.DataTexture(ee, 1, 1), T.format = t3.RedFormat, T.wrapS = t3.ClampToEdgeWrapping, T.wrapT = t3.ClampToEdgeWrapping, i = new t3.OrthographicCamera(-G, G, b, -b, -1, 10), s = new t3.WebGLRenderer({ powerPreference: "high-performance", stencil: !1 }), s.setClearColor(16777198, 1), s.autoClear = !1, s.setPixelRatio(1), s.setSize(y, v), s.outputEncoding = t3.sRGBEncoding, document.body.appendChild(s.domElement), l = new t3.Scene, j = { normal: { randomAmount: .002, brushWidth: .128, brushFrequency: 4.4, offsetSpeed: 7 }, messy: { randomAmount: .002, brushWidth: .128, brushFrequency: 1.3, offsetSpeed: 20 }, waterColor: { randomAmount: .002, brushWidth: .128, brushFrequency: 10, offsetSpeed: 3 }, thin: { randomAmount: .002, brushWidth: .002, brushFrequency: 60.2, offsetSpeed: 10 }, sigThin: { randomAmount: .002, brushWidth: .0013, brushFrequency: 8.8, offsetSpeed: 10 }, sortOfThin: { randomAmount: .002, brushWidth: .005, brushFrequency: 60.2, offsetSpeed: 10 }, sigThick: { randomAmount: .002, brushWidth: .005, brushFrequency: 0, offsetSpeed: 0 } }, (ar() < .9 && d || 563 == subIdInt) && (oe = -1), R = new r(s, { width: y, height: v }), C = new r(s, { width: y, height: v }), L = new r(s, { width: y, height: v }); const te = new t3.Vector3(y, v, window.devicePixelRatio); N = { sCurrent: fr(-100, -100), sPrevious: fr(-101, -101), sVel: fr(.01, .01), sColor1: z, sColor2: z, randomAmount: .001, brushWidth: .01, brushFrequency: 1, offsetSpeed: 10, bL: D, tR: _, rV: O, dataTexIndex: 0 }, E = new t(ye, { iResolution: { value: te }, resFactor: { value: Y }, iFrame: { value: 0 }, iChannel0: { value: null }, dataTex0: { value: T }, dataTex1: { value: T }, dataTex2: { value: T }, iChannel2: { value: Yt(128, 100, 1) }, brushes: { value: [N, N, N] }, isWaterColor: { value: 0 }, isSig: { value: 0 }, uvFlip: { value: oe }, softenEdges: { value: 0 } }); let ie = x.getRandomColor(); B = new t(ve, { iResolution: { value: te }, resFactor: { value: Y }, iChannel0: { value: null }, bgCol: { value: ie }, isWaterColor: { value: 0 }, blackAndWhite: { value: 0 }, blackPaper: { value: 0 }, isDone: { value: 0 }, randomTime: { value: 0 }, randomRot: { value: Q[2] } }), S = new t(me, {
                    iResolution: { value: fr(y, v) }, randomPos: { value: fr(ar(-.4, -.2), ar(-.4, -.2)) },
                    iChannel0: { value: null }, blackAndWhite: { value: 0 }, intensityBoost: { value: 0 }, clampBloom: { value: .56 }
                }), "Monotone" == x.fullPalette.name && (B.uniforms.blackAndWhite.value = 1), "Burgundy" != x.fullPalette.name && "Vermeer" != x.fullPalette.name || (S.uniforms.intensityBoost.value = .04, S.uniforms.clampBloom.value = .62), "Powder" != x.fullPalette.name && "Picnic" != x.fullPalette.name || (S.uniforms.intensityBoost.value = .03, S.uniforms.clampBloom.value = .6), a = new t3.Clock, A = ar(.014, .02), M = ar() < .5 ? "noise" : ar(0, 2 * F); let ae = !1; Q[0] > .9 ? (ie = cr(.15, .15, .15), B.uniforms.blackPaper.value = 1, ue = !0) : Q[1] > .85 ? (ie = cr(.75 * ie.r, .75 * ie.g, .75 * ie.b), ue = !0, ae = !0) : ie = cr(.9, .89, .84), "Monotone" == x.fullPalette.name && ae && (ie = cr(.9, .89, .84)), B.uniforms.bgCol.value = ie, ar(), function () {
                    let e = ar(), t = ["_NY", "_CDMX", "_LA", "_BER", "_LDN"]; e < .2 ? fe = t[0] : e < .41 ? fe = t[1] : e < .61 ? fe = t[2] : e < .82 ? fe = t[3] : e < 1.1 && (fe = t[4]); Ae = function () { let e, t = ar(); e = t < .005 ? "skeleton" : t < .015 ? "waterColorBorder" : t < .03 ? "inverted" : t < .09 ? "messy" : t < .16 ? "spacedOut" : "oilBorder"; subIdInt > 501 && Q[4] < .005 && (e = "skeleton"); return e }(), "skeleton" != Ae && "inverted" != Ae || "_LA" != fe || (Ae = "oilBorder"); "skeleton" == Ae && "_CDMX" == fe && (Ae = "oilBorder"); ue && "waterColorBorder" == Ae && (Ae = "oilBorder"); "waterColorBorder" == Ae && (B.uniforms.isWaterColor.value = 1, E.uniforms.isWaterColor.value = 1); "inverted" != Ae && "spacedOut" != Ae || (E.uniforms.softenEdges.value = 1); "spacedOut" != Ae || "_LA" != fe && "_CDMX" != fe || ar() < .5 && (Ae = "oilBorder"); "_NY" == fe ? function () { let e = Ot(Ae), t = Ot(Ae, !1, !0), r = Ot(Ae, !0), n = Rr(x.getRandomColor(), .02); I = [n, n]; sr(0, 3); let i = er(gt(.96)); Nt(i), Tt(i); let l = gt(1), s = er(l); Nt(s), Tt(s); let a, h = [], u = ar(); if (u < .75) { let e = sr(0, 4); a = .25 * F + .5 * F * e } else if (u < .95) { let e = sr(0, 4), t = .125 * F; ar() < .5 && (t *= -1), a = .25 * F + .5 * F * e + t } else { a = .5 * sr(0, 4) * F } let c = ar(), f = fr(1, c < .45 ? .5 : c < .6 ? .75 : c < .95 ? .25 : 1), p = ar(), g = p < .65 ? .75 : p < .85 ? .9 : 1, y = ar(), v = y < .05 ? F / 2 * 3 : y < .94 ? F / 2 : y < .97 ? 1 * F : 0 * F; .25 == f.y && (v = F / 2); let b = fr(ar(-1, 1), ar(-1.3, .5)), m = ar(), w = m < .65 ? null : m < .7 ? -.25 * F : m < .75 ? .25 * F : "noise", P = { t: b, r: a, s: f, ls: g, lr: w }, R = ar(), C = ar(), E = R < .2 ? 3 : R < .95 ? 3.5 : 4, B = C < .2 ? 3 : C < .95 ? 3.5 : 4, L = new ut([fr(.5 * -E, .5 * B), fr(.5 * E, .5 * B), fr(.5 * E, .5 * -B), fr(.5 * -E, .5 * -B)], P), S = E * B, T = ar(.3, .75); .25 == f.y && (T = dr().clamp(T, 0, .65)); S <= 10.5 && (T = dr().clamp(T, 0, .55)); let k = new dt(T); ct(L, h, 0, 5, 1, 1, .75, 3); for (let e = 0; e < h.length; e++)(qe(h[e].tCenter.x, l[0].x, l[1].x) || qe(h[e].tCenter.y, l[3].y, l[0].y)) && 0; let M = function (e, t, r, n, o) { let i = []; { let t = fr().subVectors(e.utTL, e.utBL).multiplyScalar(4), r = [[e.utTL.x + t.x, e.utTL.y + t.y], [e.utTR.x + t.x, e.utTR.y + t.y], [e.utTR.x, e.utTR.y], [e.utTL.x, e.utTL.y]]; i.push(r); let n = t.clone().multiplyScalar(-1), o = [[e.utBL.x, e.utBL.y], [e.utBR.x, e.utBR.y], [e.utBR.x + n.x, e.utBR.y + n.y], [e.utBL.x + n.x, e.utBL.y + n.y]]; i.push(o); let l = fr().subVectors(e.utTR, e.utTL).multiplyScalar(4), s = [[e.utTR.x + t.x, e.utTR.y + t.y], [e.utTR.x + l.x + t.x, e.utTR.y + l.y + t.y], [e.utBR.x + l.x + n.x, e.utBR.y + l.y + n.y], [e.utBR.x + n.x, e.utBR.y + n.y]]; i.push(s); let a = l.clone().multiplyScalar(-1), h = [[e.utTL.x + a.x + t.x, e.utTL.y + a.y + t.y], [e.utTL.x + t.x, e.utTL.y + t.y], [e.utBL.x + n.x, e.utBL.y + n.y], [e.utBL.x + a.x + n.x, e.utBL.y + a.y + n.y]]; i.push(h) } for (let e = 0; e < i.length; e++)Tt(i[e]), Nt(i[e]); return i }(L, 0, 0, 0, 0); for (let e = 0; e < M.length; e++) { let t = wt(M[e], 0, "bg"); k.addPolyNoIntersection(M[e], t) } k.externallyMaskWithPoly(i); let A = ar() < .25, W = ar(), N = W < .75 ? "none" : W < .95 ? "skew" : "noise", D = ar(.1, .35), q = ar(.25, .45), V = .2 * sr(1, 4); if (V *= ar() < .5 ? -1 : 1, d) { ar() } let z = ar(); !function (e, t) { "xA" == t ? e.sort(((e, t) => e.lowestPoint.x - t.lowestPoint.x)) : "xD" == t ? e.sort(((e, t) => t.lowestPoint.x - e.lowestPoint.x)) : "yA" == t ? e.sort(((e, t) => e.lowestPoint.y - t.lowestPoint.y)) : "yD" == t ? e.sort(((e, t) => t.lowestPoint.y - e.lowestPoint.y)) : "random" == t && e.sort(((e, t) => ke(t.lowestPoint.y) - ke(e.lowestPoint.y))) }(h, z < .15 ? "xA" : z < .3 ? "xD" : z < .825 ? "yD" : z < .85 ? "yA" : "random"); let j = [], U = h[0].poly[0][1], H = h[0].poly[0][1], X = (ar(0, .5, 1.5), ar()), Y = X < .6 ? 1 : X < .9 ? .8 : .6, J = ar(), G = J < .6 ? 1 : J < .9 ? .8 : .6, Q = ar(), $ = Q < .6 ? 1 : Q < .9 ? .8 : .6, K = ar(), ee = K < .6 ? 1 : K < .9 ? .8 : .6, te = T <= .4 ? 0 : T <= .55 ? .15 : T <= .76 ? .3 : 0; for (let e = 0; e < h.length; e++) { let t = h[e], r = h[e].unscaledPoly; t.poly[0][1] < U && (U = t.poly[0][1]), t.poly[0][1] > H && (H = t.poly[0][1]); let n = !1; (ar() < te || !qe(h[e].tCenter.x, l[0].x * Y, l[1].x * G) || !qe(h[e].tCenter.y, l[3].y * $, l[0].y * ee)) && (n = !0); let o = ar() < .1; if (n || w == -.25 * F || w == .25 * F || "noise" == w || 1 != g || o) { let e = wt(r, 0, "bg"); e.colors = [x.getRandomColor(), x.getRandomColor()], k.addPolyNoIntersection(r, e) } if (!n) { if (o) { let r = Qt(24, .5 * h[e].ww, h[e].tCenter, O, 0, O, f); t.poly = r } j.push(t) } } let re = H - U, ne = ar() > .15, oe = ar(), ie = oe < .025 ? "middle" : oe < .15 ? "LoR" : oe < .25 ? "ToB" : oe < .45 ? "TaB" : oe < .675 ? "LaR" : oe < .95 ? "LaRaTaB" : "noise"; 0 != v && v != F || "noise" != ie && "middle" != ie || (ie = "LaR"); ot() && lt(l, ie); let le = new dt(0), se = j; if (ne) { se = []; for (let e = 0; e < j.length; e++) { let t = j[e]; if (ar() < .35 && st(t.tCenter)) { let e = wt(t.poly, 0, "whiteSpace"); le.addPolyNoIntersection(t.poly, e) } else se.push(t) } } else se = j; let ae = ar() < .25, he = ar(.75, 1.25), ue = T; for (let e = 0; e < se.length; e++) { k.allExistingPolys.length > 1e3 && (k.likelihood = .5 * ue); let t = e > se.length - 4, r = he; A || (r = dr().clamp((se[e].poly[0][1] - U) / re * he + .25 + .05 * (sr(0, 5) - 2), .2, he + .25)); let n = !0; ae && (n = ar() < .5); let o = v; "none" != N && (o = "noise" == N ? v + yr(se[e].tCenter, q, D, _) * F : v + V); let i = Rt(se[e].poly, o, r, n); if (pr() < 500) for (let e = 0; e < i.edges.length; e++)Pt(i.edges[e], k, 0, "wall", !0, t); Pt(i.face, k, 0, "top", !0, t) } k.externallyMaskWithPoly(s); for (let e = 0; e < 2; e++) { let e = [...L.unscaledPoly]; Bt(e, ar(1, 2)); let t = 1; Lt(e, fr(ar(-t, t), ar(-t, t))), k.slicePolysWithPoly(e, !0) } if (se = [], ne) { for (let e = 0; e < k.allExistingPolys.length; e++) { let t = k.allExistingPolys[e]; st(t.center) ? (t.vars.type = "whiteSpace", le.addPolyNoIntersection(t.verts, t.vars)) : se.push(t) } se.length < 10 ? (se = k.allExistingPolys, le = new dt(0)) : le.externallyMaskWithPoly(i) } else se = k.allExistingPolys; if (Ie(), ot()) for (let e = 0; e < le.allExistingPolys.length; e++) { let t = le.allExistingPolys[e]; new o(t.verts, I, r) } for (let r = 0; r < se.length; r++) { let n = se[r]; de++, new o(n.verts, n.vars.colors, n.area < Z ? t : e) } }() : "_CDMX" == fe ? function () { let e = Ot(Ae), t = (Ot(Ae, !1, !0), Ot(Ae, !0)), r = Rr(x.getRandomColor(), .02); I = [r, r]; let n = er(gt(.96)); Nt(n), Tt(n); let i = gt(1), l = er(i); Nt(l), Tt(l); let s = ar(.6, 1.3, 1), a = yt(fr(1.75 * i[3].x, 1.25 * i[3].y), fr(1.75 * i[1].x, 1.25 * i[1].y), s), h = ar(), u = h < .2 ? "blobs" : h < .7 ? "octagons" : "mixed"; s < .66 && "blobs" == u && (s = .66); let c = ar(1 * s, 2.1 * s), f = .9 * s, p = 1.1 * s, g = .1, y = fr(.5, .25), v = new dt("mixed" == u ? .8 : .9); for (let e = 0; e < a.length; e++) { let t, r = fr(a[e][0], a[e][1]), n = fr(ar(f, p), ar(f, c, 1.5)); "blobs" == u ? t = 96 : "mixed" == u ? t = ar() < .4 ? 8 : 128 : "octagons" == u && (t = 8), 8 == t && n.multiplyScalar(1.1), Pt(Qt(t, 1, r, y, g, O, n, -1, null, !0), v, 0, "blob", !0, e > a.length - 4) } v.externallyMaskWithPoly(l); let b = .07, m = sr(0, 16) * F * .125, w = (fr(10, 0).rotateAround(O, m), ar(), !0), P = new dt(0), R = v.allExistingPolys, C = ar() > .5, E = 10; C && (E = .25); let B = ar(), L = B < .6 ? "LaRaTaB" : B < .8 ? "LaR" : "TaB"; if (w) { if (R = [], lt(i, L), d) { ar() } for (let e = 0; e < v.allExistingPolys.length; e++) { let t = v.allExistingPolys[e]; ar() < E && st(t.center) ? (t.vars.type = "whiteSpace", P.addPolyNoIntersection(t.verts, t.vars)) : R.push(t) } } let S = { subMode: 0, type: "solid", borderWidth: ar(.01, .03), density: 0, lineWidth: 0, stipplePercent: .25 * sr(0, 4), addPercentage: 0, noNoise: !1, smoothNoise: !0, lineNoiseFreq: O, noiseForce: 0, zeroBorderPercentage: 0, randomizeBorderWidth: ar() < .1, randomizeLineWidth: !1, randomizeDensity: !1 }, T = ar(.02, .05), k = ar(T + .02, 3 * T), M = { subMode: 0, type: "internal", borderWidth: 0, density: k, lineWidth: T, stipplePercent: 0, addPercentage: 1, noNoise: ar() < .1, smoothNoise: !0, lineNoiseFreq: fr(ar(.4, .7), ar(.4, .7)), noiseForce: ar(.03, .08), zeroBorderPercentage: .25 * sr(0, 3, 1.5), randomizeBorderWidth: ar() < .1, randomizeLineWidth: ar() < .2, randomizeDensity: ar() < .2 }, A = (ar(.03, .06), sr(0, 5), sr(0, 3, 2), ar(), fr(ar(.4, .7), ar(.4, .7)), ar(.035, .1), ar(), ar(), ar(), { subMode: 1, stipplePercent: .25 * sr(0, 4) }), W = ar() < .3 ? 10 : 100; W = "blobs" == u ? dr().clamp(W, 3, 20) : "mixed" == u ? dr().clamp(W, 3, 30) : W; let N, _ = "blobs" == u || "mixed" == u ? .04 : .03, D = ar(), q = { subMode: 4, dirMode: D < .8 ? 1 : D < .85 ? 0 : D < .9 ? 2 : 3, dir: ar(0, 2 * F), rotationAmount: ar(.005, .05), addRotation: ar() < .15, mixedDistance: ar() < .1, distance: ar(_, .2, 2), iterations: sr(3, W), mixedIterations: ar() < .25, addScale: ar() < .25, scaleAmount: ar(.05, .2), scaleUp: ar() > .5, mixedDistanceInternal: ar() < .1, topWithInternal: ar() < .5, randomInternalNoise: ar() < .25, internalBorderThickness: .01 * sr(0, 3), addNoiseToTranslation: ar() < .2 }, V = { subMode: 3, iterations: sr(4, 16), offset: ar(.02, .1), mixedOffset: ar() < .1 }, z = [M, A, q, S, V], j = ar(); j < .75 ? N = [q] : j < .8 ? N = [M] : j < 85 ? N = [A] : j < 1.1 && (N = [V]); s > .8 && N[0] == A && (N = [q]); s < .7 && ar() < .05 && (N = [S]); let U = z.indexOf(N[0]); z.splice(U, 1); let H = sr(0, 2, 1); ir(z); for (let e = 0; e < H; e++)N.push(z[e]); 1 == N.length && N[0] == M && (M.addPercentage = .65); s < .75 && ar() < .2 && (N = [q, A]); N == [q, A] && ar() < .5 && (q.distance = dr().clamp(q.distance, 0, .1), q.iterations = dr().clamp(q.iterations, 8, 100)); let X = new dt(0); for (let e = 0; e < R.length; e++) { let t = R[e], r = x.getRandomColor(); t.vars.colors = [r, r]; let n = N[sr(0, N.length)]; n == S && t.area > .3 && (n = q), n == A && t.area > .3 && (n = q), t.area > 1.5 && ((n == q || n == V) && n.iterations < 20 || n == A || n == M) && (n = ar() > .5 ? V : q, n.iterations = 20); let o = n.subMode; if (0 == o) { let e = n.borderWidth; n.randomizeBorderWidth && (e = "external" == n.type ? ar(.04, .1) : ar(.01, .024)); let r = n.lineWidth; n.randomizeLineWidth && (r = ar(.02, .06)); let o = n.density; n.randomizeDensity && (o = ar(.03, .15)), r = dr().clamp(r, 0, .75 * o); let i = n.noiseForce; n.smoothNoise || (i *= 1.5), ar() < n.zeroBorderPercentage && (e = 0); Math.round((t.center.y - -1.5) / 3 * .25 * 10), yr(t.center, 1, 1, O); let l = Ze(t, o, r, e, n.addPercentage, n.smoothNoise, n.lineNoiseFreq, n.noiseForce, n.type); for (let e = 0; e < l.allExistingPolys.length; e++) { let r = l.allExistingPolys[e]; if ("subBorder" == r.vars.type) { let e = wt(r.verts, 0, "subBorder"), n = Rr(t.vars.colors[0], .1); e.colors = [n, n], X.addPolyNoIntersection(r.verts, e) } else if ("subBG" == r.vars.type) { let e = wt(r.verts, 0, "subBG"); e.colors = [t.vars.colors[0], t.vars.colors[0]], X.addPoly(r.verts, e) } else if ("subSolid" == r.vars.type) { let e; e = wt(r.verts, 0, "fullBlob"), e.colors = t.vars.colors, X.addPoly(r.verts, e) } else { let e = wt(r.verts, 0, "fullBlob"), n = Rr(t.vars.colors[0], .05); e.colors = [n, n], X.addPoly(r.verts, e) } } } else if (1 == o) { let e = wt(t.verts, 0, "fullBlob"); e.colors = t.vars.colors, X.addPoly(t.verts, e) } else if (2 == o) { b = .25; let e = Rt(t.verts, m, b, ar() < -.5, !0), r = wt(e.face, 0, "face"); r.colors = t.vars.colors, X.addPoly(e.face, r, !0, !1) } else if (3 == o) { let e = n.offset; n.mixedOffset && (e = ar(.02, .08)); let r = $e(t, e, n.iterations, 0, !1); for (let e = 0; e < r.length; e++)Pt(r[e].verts, X, 0, "subBlob") } else if (4 == o) { let e; 0 == n.dirMode ? e = n.dir : 1 == n.dirMode ? e = 2 * yr(t.avgCenter, .5, 1, O) * F : 2 == n.dirMode ? e = ar(0, 2 * F) : 3 == n.dirMode && (e = .5 * sr(0, 4) * F); let r = n.distance; n.mixedDistance && (r = ar(.03, .2)); let o = n.iterations; n.mixedIterations && (o = sr(2, W)); let i = null; n.addRotation && (i = n.rotationAmount * F); let l = null; n.addScale && (l = -n.scaleAmount); let s = Ke(t, r, e, o, i, l, n.mixedDistanceInternal, n.addNoiseToTranslation); for (let e = 0; e < s.length; e++)if (n.topWithInternal && "lastTranslation" == s[e].vars.type && s[e].area > .006) { let t = 2 * r, o = r; n.randomInternalNoise && (t = k, o = T); let i = Ze(s[e], t, o, n.internalBorderThickness, 1, !0, fr(.5, .75), .05, "internal"); for (let t = 0; t < i.allExistingPolys.length; t++) { let r = i.allExistingPolys[t]; if ("subBorder" == r.vars.type) { let t = wt(r.verts, 0, "subBorder"), n = Rr(s[e].vars.colors[0], .1); t.colors = [n, n], X.addPolyNoIntersection(r.verts, t) } else if ("subBG" == r.vars.type) { let t = wt(r.verts, 0, "subBG"); t.colors = [s[e].vars.colors[0], s[e].vars.colors[0]], X.addPoly(r.verts, t) } else { let t = wt(r.verts, 0, "fullBlob"), n = Rr(s[e].vars.colors[0], .05); t.colors = [n, n], X.addPoly(r.verts, t) } } } else { let t = wt(s[e].verts, 0, "subBlob"); X.addPolyNoIntersection(s[e].verts, t) } } else if (5 == o) { let e = tt(t); for (let t = 0; t < e.length; t++)Pt(e[t].verts, X, 0, "subBlob") } } if (C) if (R = [], w) { for (let e = 0; e < X.allExistingPolys.length; e++) { let t = X.allExistingPolys[e]; st(t.center) ? (t.vars.type = "whiteSpace", P.addPolyNoIntersection(t.verts, t.vars)) : R.push(t) } R.length < 10 && (R = X.allExistingPolys, P = new dt(0)) } else R = X.allExistingPolys; else R = X.allExistingPolys; P.externallyMaskWithPoly(n); for (let e = 0; e < P.allExistingPolys.length; e++) { let r = P.allExistingPolys[e]; new o(r.verts, I, t) } let Y = []; for (let t = 0; t < R.length; t++) { let r = R[t]; if ("fullBlobPoisson" == r.vars.type && "skeleton" != Ae) { new o(r.verts, r.vars.colors, e); let t = et(r), n = Lr(r.vars.colors[1], .25), i = [n, n]; for (let e = 0; e < t.length; e++)Y.push({ stipple: t[e], colors: i }) } else r.vars.type, new o(r.verts, r.vars.colors, e); "subBorder" != r.vars.type && de++ } for (let e = 0; e < Y.length; e++) { let t = Y[e]; new o(t.stipple, t.colors, Ot("tiny")) } }() : "_LA" == fe ? function () { ar(1, 3), ar(2, 4), ar(3, 5); let e = Ot(Ae), t = Ot(Ae, !1, !0), r = Ot(Ae, !0), n = Rr(x.getRandomColor(), .02); I = [n, n]; let i = er(gt(.96)); Nt(i), Tt(i); let l = gt(1), s = er(l); Nt(s), Tt(s); let a, h = new dt(0), u = .016; 1 != subIdInt && subIdInt != ne && (a = je(u)); Pt(s, h, 0, "background"), (1 == subIdInt || subIdInt == ne) && (a = je(u)); for (let e = 0; e < a.length; e++) { let t = a[e].skinny; a[e].thick; Pt(t, h, 0, "road", !1) } let c = new dt(0); Pt(s, c, 0, "background"); for (let e = 0; e < a.length; e++) { let t = a[e].skinny; a[e].thick; Pt(t, c, 0, "road", !1) } if (c.externallyMaskWithPoly(s), d) { ar() } for (let e = 0; e < h.allExistingPolys.length; e++)if ("background" == h.allExistingPolys[e].vars.type) { let t = He(Ye(h.allExistingPolys[e].verts), .5 * u, .5 * u); for (let e = 0; e < t.length; e++) { let r = t[e].ramp, n = t[e].roundabout; null != n && Pt(n, c, 0, "roundabout", !0), Pt(r, c, 0, "road", !0) } } else Pt(h.allExistingPolys[e].verts, c, 0, "background", !0); c.externallyMaskWithPoly(i); let f = ar() > 1.75; ot() && lt(l); let p = new dt(0), g = []; if (f && "spacedOut" != Ae) { for (let e = 0; e < c.allExistingPolys.length; e++) { let t = c.allExistingPolys[e]; !0 && st(t.avgCenter) ? (t.vars.type = "whiteSpace", p.addPolyNoIntersection(t.verts, t.vars)) : g.push(t) } g.length < 10 && (g = c.allExistingPolys, p = new dt(0)) } else g = c.allExistingPolys; if (Ie(), ot()) for (let e = 0; e < p.allExistingPolys.length; e++) { let t = p.allExistingPolys[e]; new o(t.verts, I, r) } let y = e; for (let r = 0; r < g.length; r++) { let n = g[r]; "road" == n.vars.type || "roundabout" == n.vars.type ? (de++, new o(n.verts, null, n.area < Z ? t : y)) : (de++, new o(n.verts, null, n.area < Z ? t : e)) } let v = new dt; if ("spacedOut" != Ae) { for (let e = 0; e < a.length; e++) { a[e].skinny; let t = a[e].thick; Nt(t), Pt(t, v, 0) } v.externallyMaskWithPoly(s); for (let r = 0; r < v.allExistingPolys.length; r++) { let n = v.allExistingPolys[r], i = x.getRandomColor(); de++, "spacedOut" != Ae ? new o(n.verts, [i, i], n.area < Z ? t : e) : new o(n.verts, [cr(1, 1, 1), cr(1, 1, 1)], Ot("oilNoBorder")) } } }() : "_BER" == fe ? function () { let e = Ot(Ae), t = Ot(Ae, !1, !0), r = Ot(Ae, !0), n = Rr(x.getRandomColor(), .02); I = [n, n]; let i = er(gt(.96)); Nt(i), Tt(i); let l = gt(1.03), s = er(l); Nt(s), Tt(s); let a = l[1].x - l[3].x, h = l[1].y - l[3].y, u = .5 * a, c = .5 * h, f = { t: O, r: 0, s: _, ls: 1, lr: 0 }, p = 1 * h, g = 1 * h, y = new ut([fr(.5 * -p, .5 * g), fr(.5 * p, .5 * g), fr(.5 * p, .5 * -g), fr(.5 * -p, .5 * -g)], f), v = ar() < .8 ? 3 : 2, b = ar(), m = b < .7 ? 2 : b < .9 ? 1 : 3, w = [], P = [], R = []; ct(y, w, 0, v, 1, 1, 1, 2), ct(y, P, 0, m, 1, 1, 1, 2); let C = ["qCircle", "tri", "plus", "x", "diagonal", "straight", "tallTri"], E = ["qCircle", "tri", "circle", "diagonal", "straight", "lines", "plus", "x", "halfCircles", "tallTri"]; 3 == m && (E = C); let B = ar(), L = B < .4 ? 1 : B < .8 ? 2 : B < 1.5 ? 3 : 0; ir(E); let S = []; for (let e = 0; e < L; e++)S.push(E[e]); let T = ar() < .8, k = .5 * sr(0, 4) * F, M = []; for (let e = 0; e < P.length; e++) { if (!qe(P[e].center.x, 1.25 * -u, 1.25 * u) || !qe(P[e].center.y, 1.25 * -c, 1.25 * c)) continue; T && (k = .5 * sr(0, 4) * F); let t = S[sr(0, S.length)], r = Ve(P[e], t, k); for (let e = 0; e < r.length; e++)M.push(r[e]) } let A = ar(), W = A < .7 ? 2 : A < .8 ? 3 : A < .95 ? 4 : 1; for (let e = 0; e < w.length; e++) { if (!qe(w[e].center.x, -u, u) || !qe(w[e].center.y, -c, c)) continue; x.getRandomColor(); let t = fr(1.5 * w[e].center.x, w[e].center.y), r = dr().clamp(yr(t, W, .5, O) + .5, 0, 1); r = Math.round(1 - Math.pow(r, 1.1)), r < .5 && R.push(w[e].poly) } let N = ar(); pt(P, N < .6 ? "random" : N < .7 ? "yA" : N < .8 ? "yD" : N < .9 ? "xA" : "xD"); let D = kt(R), q = new dt(0), V = ar(), z = V < .5 ? 1 : V < .75 ? .75 : V < .9 ? .5 : .25; 1 == m && (V = ar() < .5 ? 1 : .666); let j = Math.floor(M.length * z); for (let e = 0; e < j; e++)Pt(M[e].verts, q, 0, M[e].vars.type); let U = .75; for (let e = 0; e < D.length; e++) { x.getRandomColor(); let t = D[e]; Pt(t, q, 0, "building"); let n = Mt(t, !0), i = n[1].x - n[3].x, l = n[1].y - n[3].y, s = [nr(n[3].x + .5 * i, $), nr(n[3].y + .5 * l, $)]; if (i > U) { let e = Jt(fr(.01, l), tr(s), 0); "oilBorder" != Ae && "waterColorBorder" != Ae || new o(e, I, r), q.addPoly(e, null, !1) } if (l > U) { let e = Jt(fr(i, .01), tr(s), 0); "oilBorder" != Ae && "waterColorBorder" != Ae || new o(e, I, r), q.addPoly(e, null, !1) } } for (let e = j; e < M.length; e++)Pt(M[e].verts, q, 0, "obj"); let H = .5 * sr(0, 4) * F, X = .5 * sr(0, 4) * F + .25 * F; ar() < .5 && (ar() < .5 ? X -= .125 * F : X += .125 * F); let Y = ar() < .875 ? X : H, J = ar() > .1, G = 0, K = "null", ee = ar() < .5; if (J) { let e = sr(0, 2) * F + .5 * F; ar() < .25 && (e += .5 * F); let t = .5 * sr(0, 4) * F + .25 * F; ar() < .5 && (ar() < .5 ? t -= .125 * F : t += .125 * F); let r = ar() < .8 ? t : e; nr(Math.abs(r / F - Y / F), 3) % .25 == 0 && (r += .25 * F); let n = ar(); K = n < .4 ? "lines" : n < .7 ? "grid" : n < 1.1 ? "circles" : 0; let o = ar(); G = o < .1 ? 1 : o < .3 ? 2 : o < .8 ? 3 : 4, "lines" == K ? G *= 2 : "grid" == K && 3 == G && (G += ar() < .5 ? -1 : 1), function (e, t, r, n, o, i, l) { let s, a, h, u, c, f, d, p, g, y = r.x - t.x, v = r.y - t.y, x = [[t.x, r.y], [r.x, r.y], [r.x, t.y], [t.x, t.y]], b = [], m = "split"; switch (n) { case "grid": g = at(x, l), g = lr(g), s = gr(g[0].x, g[0].y, g[1].x, g[1].y), a = gr(g[0].x, g[0].y, g[3].x, g[3].y), h = g[1].clone().sub(g[0]), u = g[3].clone().sub(g[0]), c = g[3].clone().lerp(g[0], .5), f = h.clone().divideScalar(o + 1), d = u.clone().divideScalar(o + 1), p = c.clone().add(fr(ar(-.5, .5), ar(-.65, .65))); for (let t = 0; t < o; t++) { p.add(f); let t = Jt(fr(De, a), p, -l); b.push({ shape: t, draw: i }), m = i ? "split" : "splitNoDraw", Pt(t, e, 0, m, !0) } c = g[0].clone().lerp(g[1], .5), p = c.clone().add(fr(ar(-.5, .5), ar(-.5, .5))); for (let t = 0; t < o; t++) { p.add(d), m = i ? "split" : "splitNoDraw", Pt(Jt(fr(s, De), p, -l), e, 0, m, !0) } break; case "lines": g = at(x, l), g = lr(g), s = gr(g[0].x, g[0].y, g[1].x, g[1].y), a = gr(g[0].x, g[0].y, g[3].x, g[3].y), h = g[1].clone().sub(g[0]), c = g[3].clone().lerp(g[0], .5), f = h.clone().divideScalar(o + 1), p = c.clone().add(fr(ar(-.5, .5), ar(-.5, .5))); for (let t = 0; t < o; t++) { p.add(f), m = i ? "split" : "splitNoDraw", Pt(Jt(fr(De, a), p, -l), e, 0, m, !0) } break; case "circles": let t = sr(3, 5), r = sr(3, 7); f = y / t, d = v / r; let n = .125 * sr(0, 16) * F, w = ar(), P = w < .2 ? 24 : w < .6 ? 4 : 2; 2 == P && n % (.5 * F) == 0 && (n -= .125 * F); let R = 24 == P ? .75 : 1, C = fr(ar(-.5, .5), ar(-.5, .5)), E = ar(.2, .375), B = ar() < .5, L = ar(.4, 1.5); for (let o = 0; o < r; o++)for (let r = 0; r < t; r++) { let t = fr(r * f + .5 * f - .5 * y + C.x, o * d + .5 * d - .5 * v + C.y); if (P > 2) { m = i ? "split" : "splitNoDraw", Pt(Qt(P, f * E * R, t, O, 0, O, _, n), e, 0, m, !0) } else { B && (L = ar(.4, 1.5)), m = i ? "split" : "splitNoDraw", Pt(Jt(fr(L, .03), t, n), e, 0, m, !0) } } } }(q, l[3], l[1], K, G, ee, r) } let te = ar(), re = te < .05 ? 1 : te < .2 ? 2 : te < .75 ? 3 : te < .9 ? 4 : 5; if (d) { ar(); 500 == subIdInt && (ar(), ar(), ar(), ar(), ar()), 1 == re && (re = sr(2, 5)) } let ne = ar(), oe = ne < .6 ? "random" : ne < .7 ? "yA" : ne < .8 ? "yD" : ne < .9 ? "xA" : "xD"; "lines" == K && G > 4 && (oe = "random"); q.sortPolys(oe), q.externallyMaskWithPoly(i); let ie = [], le = q.allExistingPolys.length - 1, se = ar() > .25; for (; le >= 0;) { let e = q.allExistingPolys[le]; if (ee && se) { if ("split" == e.vars.type) { let e = q.allExistingPolys.splice(le, 1); ie.push(e[0]) } } else if (!ee && "splitNoDraw" == e.vars.type) { let e = q.allExistingPolys.splice(le, 1); ie.push(e[0]) } le-- } if (ee && se) for (let e = 0; e < ie.length; e++) { let t = sr(0, Math.floor(.666 * q.allExistingPolys.length)); q.allExistingPolys.splice(t, 0, ie[e]) } else if (!ee) for (let e = 0; e < ie.length; e++)"spacedOut" != Ae && "inverted" != Ae && "messy" != Ae && "oilBorder" != Ae && "waterColorBorder" != Ae || new o(ie[e].verts, I, Ot(Ae, !0)); 500 == subIdInt && ar(); let ae = ar(.05, .1), he = 2, ue = new dt(0), ce = ar() > .075; ot() && lt(l); let fe = new dt(0), pe = []; if (ce) { for (let e = 0; e < q.allExistingPolys.length; e++) { let t = q.allExistingPolys[e]; st(t.center) ? (t.vars.type = "whiteSpace", fe.addPolyNoIntersection(t.verts, t.vars)) : pe.push(t) } pe.length < 8 ? (pe = q.allExistingPolys, fe = new dt(0)) : fe.externallyMaskWithPoly(i) } else pe = q.allExistingPolys; for (let e = 0; e < pe.length; e++) { let t = pe[e], r = null, n = sr(1, re + 1, 1.1); if ("bg" == t.vars.type) Pt(t.verts, ue, 0, "bg"); else if ("objiii" == t.vars.type && ar() < .5) Pt(t.verts, ue, 0, "obj"); else { let e = n; "split" == t.vars.type ? e = Math.min(n, 2) : "splitCirc" == t.vars.type && (e = Math.min(n, 1)); for (let n = 0; n < e; n++) { let o = fr(ae * he + 0 * Q[0], 0).rotateAround(O, Y - 1 * F); if (o.x = nr(o.x, $), o.y = nr(o.y, $), null == r) { r = Rt(t.verts, Y, ae) } else r = ze(r); if (0 != n) { Lt(r.face, o); for (let e = 0; e < r.edges.length; e++)Lt(r.edges[e], o) } for (let e = 0; e < r.edges.length; e++)Pt(r.edges[e], ue, 0, "edge"); n == e - 1 && "obj" == t.vars.type ? Pt(r.face, ue, 0, "obj") : Pt(r.face, ue, 0, n == e - 1 ? "cap" : "face") } } } if (pe = ue.allExistingPolys, ce && ar() < .6) { pe = []; for (let e = 0; e < ue.allExistingPolys.length; e++) { let t = ue.allExistingPolys[e]; st(t.center) ? (t.vars.type = "whiteSpace", fe.addPolyNoIntersection(t.verts, t.vars)) : pe.push(t) } pe.length < 8 ? (pe = ue.allExistingPolys, fe = new dt(0)) : fe.externallyMaskWithPoly(i) } else pe = ue.allExistingPolys; if (Ie(), ot()) for (let e = 0; e < fe.allExistingPolys.length; e++) { let t = fe.allExistingPolys[e]; new o(t.verts, I, r) } for (let r = 0; r < pe.length; r++) { let n = pe[r]; de++, new o(n.verts, n.vars.colors, n.area < Z ? t : e) } }() : "_LDN" == fe && function () {
                        let e = ar(), t = sr(1, 4), r = Ot(Ae), n = Ot(Ae, !1, !0), i = Ot(Ae, !0), l = Rr(x.getRandomColor(), .02); I = [l, l]; let s = gt(1.03), a = er(s); Nt(a), Tt(a); let h = er(gt(.96)); Nt(h), Tt(h); ar(), ar(); let u = fr(1, 1.5); var c = new zr, f = { xl: -u.x, xr: u.x, yt: -u.y, yb: u.y }; let p = []; for (let e = 0; e < 8; e++) { let e = fr(ar(-u.x, u.x), ar(-u.y, u.y)); p.push(e.clone()) } let g = ["obelisk", "crown", "trough", "pillar", "dome", "yArc", "x", "m"], y = ["obelisk", "crown", "trough", "pillar", "x", "m"]; ir(g), ir(y); let v = []; for (let e = 0; e < t; e++)v.push(g[e]); let b = []; for (let e = 0; e < t; e++)b.push(y[e]); v.includes("yArc") || ar() < .25 && (v.pop(), v.push("yArc")); let m = [], w = e < .35 ? "field" : e < .9 ? "poisson" : "radial"; 1 == v.length && "pillar" == v[0] && (v[0] = "yArc"); 1 == b.length && "pillar" == b[0] && (b[0] = "obelisk"); let P = ar() < .35, R = P ? fr(.9, .9) : fr(.8, .8); ar() < .75 && (We = ar(.2, .7)); if (function (e, t, r, n, i, l, s) {
                            let a, h, u, c, f, d, p = l[3], g = l[1]; switch (e) {
                                case "radial": a = sr(4, 10); let e = ar(.1, .7), y = fr(ar(.75 * p[0], .75 * g[0]), ar(.75 * p[1], .75 * g[1])), v = 2 * F / a, x = ar(0, 2 * F), b = fr(), m = .25 * sr(0, 8) * F; d = a > 7 ? r : t; for (let t = 0; t < a; t++) { if (b.set(e, 0), b.rotateAround(O, v * t + x), b.add(y), "oilBorder" == Ae && qe(b.x, -.95, .95) && qe(b.y, -1.4, 1.4)) { let e = Qt(4, .01, b); new o(e, I, Ot("tiny")) } let r = Ne(d[sr(0, d.length)], b, l, !0, v * t + x + m, b); if (i.push(r), h = s.x - .15, c = ar(h, s.x), u = s.y - .4, f = ar(u, s.y), ar() < c) for (let e = 0; e < r.length; e++) { let t = tr(r[e]); vt(t, 0) && ar() < f && n.push(t) } } break; case "poisson": let w = ar(.65, .85), P = yt(fr(l[3][0], l[3][1] + .2), tr(l[1]), w); P.length < 4 && P.push([ar(-.9, -.15)]), d = w < .7 ? r : t; for (let e = 0; e < P.length; e++) {
                                    if (!qe(P[e][0], -.95, .95) || !qe(P[e][1], -1.5, 1.5)) continue; let t = d[sr(0, d.length)], r = tr(P[e]);
                                    if ("oilBorder" == Ae && qe(r.x, -.95, .95) && qe(r.y, -1.4, 1.4)) { let e = Qt(4, .01, r); new o(e, I, Ot("tiny")) } let a = Ne(t, r, l); if (i.push(a), h = s.x - .15, c = ar(h, s.x), u = s.y - .1, f = ar(u, s.y), ar() < c) for (let e = 0; e < a.length; e++) { let t = tr(a[e]); vt(t, 0) && ar() < f && n.push(t) }
                                } break; case "field": let R = sr(3, 6), C = sr(3, 7), E = g[0] - p[0], B = g[1] - p[1], L = E / R, S = B / C, T = .5 * sr(0, 4) * F + .25 * F, k = ar() < .35, M = fr(ar(-.333, .333), ar(-.333, .333)), A = fr(ar(-1e3, 1e3), ar(-1e3, 1e3)); d = R * C >= 20 ? r : t; for (let e = 0; e < C; e++)for (let t = 0; t < R; t++) { let r = t * L + .5 * L - .5 * E + M.x, a = e * S + .5 * S - .5 * B + M.y, p = d[sr(0, d.length)], g = fr(r, a); if ("oilBorder" == Ae && qe(g.x, -.95, .95) && qe(g.y, -1.4, 1.4)) { let e = Qt(4, .01, g); new o(e, I, Ot("tiny")) } k && (T = yr(g, .065, 1, A) * F); let y = Ne(p, g, l, !1, T, g); i.push(y); let v = dr().lerp(1, .25, R * C / 30); if (h = s.x - .15, c = ar(h, s.x), R * C > 20 && (c = dr().clamp(c, 0, v)), u = s.y - .1, f = ar(u, s.y), R * C > 20 && (f = dr().clamp(f, 0, v)), ar() < c) for (let e = 0; e < y.length; e++) { let t = tr(y[e]); vt(t, 0) && ar() < f && n.push(t) } }
                            }
                        }(w, v, b, p, m, a, R), d) { ar() } let C = ar(); !function (e, t, r) { switch (e) { case "clock": let e = 2 * ar() * F, r = ar(.04, .12); for (let n = 0; n < 1; n++) { let n = fr(ar(-1, 1), ar(-.5, 1.4)); for (let o = 0; o < 1; o++) { let o = Qt(24, 6 * r, n, _, 0, O, _, e); for (let e = 0; e < o.length; e++) { let r = tr(o[e]); vt(r, 0) && ar() < .85 && t.push(r) } let i = Qt(12, 4 * r, n, _, 0, O, _, e); for (let e = 0; e < i.length; e++) { let r = tr(i[e]); vt(r, 0) && ar() < .85 && t.push(r) } let l = Qt(12, 2 * r, n, _, 0, O, _, e); for (let e = 0; e < l.length; e++) { let r = tr(l[e]); vt(r, 0) && ar() < .85 && t.push(r) } let s = Qt(12, r, n, _, 0, O, _, e); for (let e = 0; e < s.length; e++) { let r = tr(s[e]); vt(r, 0) && ar() < .85 && t.push(r) } } } break; case "river": let n = ar(0, 2), o = ar(.1, .5), i = ar(.1, .5), l = ar(3, 10), s = ar(-.9, .9); for (let e = 0; e < 35; e++) { let r = Math.sin(e / l + n * F) * o + s, a = e / 35 * 2 - 1, h = fr(a, r), u = fr(a, r - i); vt(h, 0) && ar() < .75 && t.push(h.clone()), vt(u, 0) && ar() < .75 && t.push(u.clone()) } break; case "shield": let a = function (e, t, r, n) { let o = t / n, i = r / (n - 1), l = [], s = 1, a = 0; for (let t = 0; t < n; t++) { for (let r = 0; r < s; r++) { let s = fr(), h = e.x + r * o - .5 * o * t; s.set(h, e.y + a - .5 * (n - 1) * i), l.push(s) } a += i, s++ } return l }(fr(ar(-.75, .75), ar(-1.2, 1.2)), ar(.5, 1.1), ar(.7, 1.4), sr(7, 12)); for (let e = 0; e < a.length; e++)t.push(a[e]); break; case "grid": let h = ar(.75, 1.5), u = ar(.75, 1.5), c = sr(2, 7), f = sr(3, 8), d = h / c, p = u / f, g = (sr(0, 8), fr(ar(-.6, .6), ar(-.75, .75))), y = ar(0, 2 * F), v = ar(0, 2 * F); for (let e = 0; e < f; e++)for (let r = 0; r < c; r++) { let n = fr(r * d + .5 * d - .5 * h, e * p + .5 * p - .5 * u); n.rotateAround(O, y), n.add(g); let o = $t(fr(.5 * d, .5 * d), n, v, 1.5, O, 0, O); for (let e = 0; e < o.length; e++) { let r = tr(o[e]); vt(r, 0) && ar() < .75 && t.push(r) } } } }(C < .35 ? "clock" : C < .55 ? "river" : C < .85 ? "grid" : "shield", p); let E = new dt(.5); var B = c.compute(p, f); let L = []; B.cells.forEach((e => { let t = function (e) { let t = []; if (e.halfedges.length < 1) return null; let r = e.halfedges, n = 0, o = [0, 0]; for (; n < r.length;) { let e = r[n].getStartpoint(); t.push([e.x, e.y]), o[0] += e.x, o[1] += e.y, n++ } o[0] /= t.length, o[1] /= t.length; let i = Wt(t), l = r[0].getStartpoint(); return t.push([l.x, l.y]), { verts: t, center: o, area: i } }(e); null != t && (L.push(t.verts), Pt(t.verts, E, 0, "cell")) })); let S = ar(), T = S < .8 ? "random" : S < .85 ? "yA" : S < .9 ? "yD" : S < .95 ? "xA" : "xD"; for (let e = 0; e < m.length; e++)Pt(m[e], E, 0, "arc"); E.sortPolys(T), E.externallyMaskWithPoly(a); let k = ar() > .05; ot() && lt(s); let M = new dt(0), A = []; if (k) { for (let e = 0; e < E.allExistingPolys.length; e++) { let t = E.allExistingPolys[e]; !0 && st(t.avgCenter) ? (t.vars.type = "whiteSpace", M.addPolyNoIntersection(t.verts, t.vars)) : A.push(t) } A.length < 10 ? (A = E.allExistingPolys, M = new dt(0)) : M.externallyMaskWithPoly(h) } else A = E.allExistingPolys; let W = new dt(0), N = sr(0, 4) * F + .25 * F, D = ar() < .25, q = ar(.05, .12); A.length < 100 ? (P = !1, D = !0, W.likelihood = .5) : A.length < 150 && (D = !0, W.likelihood = .5); for (let e = 0; e < A.length; e++) { let t = A[e], r = t.verts; if (!P && ar() > .5) { D && (N = sr(0, 4) * F + .25 * F); let e = Rt(r, N, q, !1); for (let r = 0; r < e.edges.length; r++)Pt(e.edges[r], W, 0, t.vars.type); Pt(e.face, W, 0, t.vars.type) } else Pt(t.verts, W, 0, t.vars.type) } if (W.externallyMaskWithPoly(h, 0, ["arc", "cell"]), Ie(), ot()) for (let e = 0; e < M.allExistingPolys.length; e++) { let t = M.allExistingPolys[e]; new o(t.verts, I, i) } for (let e = 0; e < W.allExistingPolys.length; e++) { let t = W.allExistingPolys[e]; de++, new o(t.verts, t.vars.colors, t.area < Z ? n : r) }
                    }(); re = Q[3] < .06, Te = performance.now(), Dt = Te - Se; for (let e = 0; e < H; e++)if (p.getCount() > 0) { let e = p.dequeue(); e.createBufferObjects(), U.push(e) } else U.push(new n)
                }(), s.domElement.style.position = "absolute", s.domElement.style.display = "block", s.domElement.style.inset = "0px", s.domElement.style.margin = "auto", s.domElement.style.width = "auto", s.domElement.style.height = "100%", _t(), window.addEventListener("resize", _t), document.addEventListener("keydown", (e => { if (67 == e.keyCode) Ht ? window.alert("Image has already been saved.") : Xt(!1); else if (52 == e.keyCode) { let e = window.location.href.split("?"), t = "?r=1.5"; J && (t += "&f=" + Ut.toString()), window.location.href = e[0] + t } else if (56 == e.keyCode) { let e = window.location.href.split("?"), t = "?r=3"; J && (t += "&f=" + Ut.toString()), window.location.href = e[0] + t } else if (49 == e.keyCode) { let e = window.location.href.split("?"), t = "?f=1"; V && (t += "&r=" + Y), window.location.href = e[0] + t } else if (50 == e.keyCode) { let e = window.location.href.split("?"), t = "?f=2"; V && (t += "&r=" + Y), window.location.href = e[0] + t } })), PolyBool.epsilon(6.66e-9)
            }(), function e() { requestAnimationFrame(e), jt ? c && !Ht && performance.now() - Se >= 5e3 && (Xt(c), Ht = !0) : function () { { let e = performance.now(); ae = dr().clamp(.001 * (e - he), .01, .1); let t = 1 / ae; W.enqueue(t), se += t, W.getCount() > ie && (se -= W.dequeue(), le = se / W.getCount()), he = e } if (!jt) { a.getDelta(); le > 58 ? qt++ : le < 36 && qt--, qt > Ut && (qt = Ut), qt < 2 && 10 == Ut && (qt = 2); let e = 0; for (let t = 0; t < qt; t++) { let t = [], r = []; e = 0; for (let n = 0; n < H; n++) { if (t.push(N), r.push(T), U[n].finished) if (U[n].dispose(), p.getCount() > 0) { let e = !1, t = null, r = 0, o = !1; for (; !e;) { if (r++, p.getCount() <= 0) { o = !0; break } let n = p.dequeue(); if (n.createBufferObjects(), !n.skipRendering || r > 10) { t = n, e = !0; break } } o || (U[n] = t) } else e++; U[n].update(), U[n].cPos.x == U[n].pPos.x && (U[n].cPos.y, U[n].pPos.y), r[n] = U[n].polyDataTex, t[n] = { sCurrent: U[n].cPos, sPrevious: U[n].pPos, sColor1: U[n].color1, sColor2: U[n].color2, sVel: U[n].cVel, randomAmount: U[n].rA, brushWidth: U[n].width, brushFrequency: U[n].frequency, offsetSpeed: U[n].offsetSpeed, bL: U[n].bL, tR: U[n].tR, rV: U[n].rV, dataTexIndex: n } } (e < H || !jt) && (E.uniforms.dataTex0.value = r[0], E.uniforms.dataTex1.value = r[1], E.uniforms.dataTex2.value = r[2], E.uniforms.iChannel0.value = R.readBuffer.texture, E.uniforms.iFrame.value = J, E.uniforms.brushes.value = t, R.render(E.scene, i), B.uniforms.iChannel0.value = R.readBuffer.texture, S.uniforms.iChannel0.value = C.readBuffer.texture), J++ } if ((e < H || !jt) && (C.render(B.scene, i, !0), e >= H)) { if ("oilBorder" != Ae && "waterColorBorder" != Ae || (B.uniforms.isDone.value = 1), re && !Vt) { E.uniforms.isSig.value = 1, -1 == oe && (E.uniforms.uvFlip.value = 1); let e = fr(ar(.85, .91), ar(-1.46, -1.5)), t = Gt(Pe, 6e-5, e), r = Gt(Re, 6e-5, e), n = Gt(Ce, 6e-5, e), i = Ot("sigThin"), l = [cr(10, 10, 10), cr(10, 10, 10)]; new o(t, l, i), new o(r, l, i), new o(n, l, i) } Vt = !0, zt++ } zt >= 10 && ("skeleton" != Ae && (C.render(B.scene, i), L.render(S.scene, i, !0)), jt = !0) } }() }();

    </script>